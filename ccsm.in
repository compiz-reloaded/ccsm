#!/usr/bin/env python

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, 
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
# Authors: Quinn Storm (quinn@beryl-project.org)
# Copyright (C) 2007 Quinn Storm


import os
import compizconfig
import pygtk
pygtk.require('2.0')
import gtk
import gtk.gdk
import cairo

if gtk.pygtk_version < (2,10,0):
    print "PyGtk 2.10.0 or later required"
    raise SystemExit

import gobject
import os
import re
gdk = gtk.gdk
ccs = compizconfig
from xml.sax.saxutils import escape as EscapeMarkup

DataDir = "@prefix@/share"
IconDir = DataDir+"/icons/hicolor/scalable"
PixmapDir = DataDir+"/ccsm/images"
CurrentScreenNum = 0

def Write(ctx):
	ctx.Write()

def getScreens():
	screens = []
	display = gtk.gdk.display_get_default()
	nScreens = display.get_n_screens()
	for i in range(nScreens):
		screens.append(i)
	return screens

def CheckConflict(setting, con, typ):
	if typ == 'Key':
		cval = setting.Value[0]
	elif typ == 'Button':
		cval = setting.Value[1]

	msg = "The new value for the %s binding for the action <b>%s</b> " +\
		  "in plugin <b>%s</b> conflicts with the action <b>%s</b> of the <b>%s</b> plugin.\n" +\
		  "Do you wish to disable <b>%s</b> in the <b>%s</b> plugin?\n" +\
		  "If you click No, this option will not be set."
	 
	msg = msg % (typ, setting.ShortDesc, setting.Plugin.ShortDesc, con.ShortDesc, con.Plugin.ShortDesc, con.ShortDesc, con.Plugin.ShortDesc)
	
	dlg = gtk.MessageDialog(parent=mainWin, flags=gtk.DIALOG_MODAL, type=gtk.MESSAGE_WARNING, buttons=gtk.BUTTONS_YES_NO)
	dlg.set_markup(msg)
	dlg.show_all()
	ret = dlg.run()
	dlg.destroy()

	return ret

def CheckActionConflicts(setting, key, button, bell, edges):
	keyCon = []
	buttonCon = []
	
	# this might be a bit slow but anyway...
	for plugin in setting.Plugin.Context.Plugins.values():
		if plugin.Enabled:
			settings = sum((z.values() for z in [plugin.Screens[CurrentScreenNum]]+[plugin.Display]), [])
			for s in settings:
				if s.Type == 'Action' and s != setting:
					if s.Value[0] == key:
						keyCon.append(s)
					if s.Value[1] == button:
						buttonCon.append(s)

	if len(keyCon) and key and key.lower() != 'disabled' and key.lower() != 'none':
		for k in keyCon:
			ret = CheckConflict(setting, k, 'Key')
			if ret == gtk.RESPONSE_YES:
				value = k.Value
				k.Value = ['None', value[1], value[2], value[3]]
			if ret == gtk.RESPONSE_NO:
				return False
	
	if len(buttonCon) and button and button.lower() != 'disabled' and button.lower() != 'none':
		for b in buttonCon:
			ret = CheckConflict(setting, b, 'Button')
			if ret == gtk.RESPONSE_YES:
				value = b.Value
				b.Value = [value[0], 'None', value[2], value[3]]
			if ret == gtk.RESPONSE_NO:
				return False
	return True

# Not used for plugin dependencies (which are handled by ccs) but own feature checking e.g. image support
def CheckFeature(context, feature):
	for plugin in context.Plugins.values():
		if plugin.Features.__contains__(feature):
			if plugin.Enabled:
				return True
			else:
				msg = "You are trying to use the feature <b>%s</b> which is provided by <b>%s</b>.\n" +\
					  "This plugin is currently disabled.\n" +\
					  "Do you wish to enable <b>%s</b> so the feature is available?"
				 
				msg = msg % (feature, plugin.ShortDesc, plugin.ShortDesc)
				
				dlg = gtk.MessageDialog(parent=mainWin, flags=gtk.DIALOG_MODAL, type=gtk.MESSAGE_WARNING, buttons=gtk.BUTTONS_YES_NO)
				dlg.set_markup(msg)
				dlg.show_all()
				ret = dlg.run()
				dlg.destroy()

				if ret == gtk.RESPONSE_YES:
					plugin.Enabled = True
					context.Write()
					return True
				if ret == gtk.RESPONSE_NO:
					return False
	
	return False

class PureVirtualError(Exception):
	pass

TDef = gtk.FILL | gtk.EXPAND
TXp = 4
TYp = 2

class SettingItem:
	def __init__(self, Setting):
		self.Custom = False
		self.Setting = Setting
		self.Blocked = 0
		self.MakeLabel()
		self.Reset = gtk.Button()
		self.Reset.set_image(gtk.image_new_from_stock(
			gtk.STOCK_CLEAR, gtk.ICON_SIZE_BUTTON))
		self.Reset.connect('clicked', self.DoReset)
		self._Init()

	def Attach(self, table, row):
		if self.Custom:
			table.attach(self.Widget, 0, 100, row, row+1, TDef, TDef, TXp, TYp)
		else:
			table.attach(self.Label, 0, 1, row, row+1, gtk.FILL, TDef, TXp, TYp)
			table.attach(self.Widget, 1, 99, row, row+1, TDef, TDef, TXp, TYp)
			table.attach(self.Reset, 99, 100, row, row+1, 0, TDef, TXp, TYp)

	def PureVirtual(self, str):
		raise PureVirtualError, str, self.Setting.Name

	def _Init(self):
		self.PureVirtual('_Init')
	
	def DoReset(self, foo):
		self.Setting.Reset()
		Write(self.Setting.Plugin.Context)
		self.Read()

	def MakeLabel(self):
		self.Label = gtk.Label(self.Setting.ShortDesc)
		self.Label.props.xalign = 0
		self.Label.props.wrap_mode = gtk.WRAP_WORD
		self.Label.set_size_request(160, -1)
		self.Label.set_line_wrap(True)

	def Block(self):
		self.Blocked = self.Blocked+1
	
	def UnBlock(self):
		self.Blocked = self.Blocked-1

	def Read(self):
		self.Block()
		self._Read()
		self.UnBlock()

	def _Read(self):
		self.PureVirtual('_Read')

	def Changed(self, *args, **kwargs):
		if self.Blocked <= 0:
			self._Changed()
			Write(self.Setting.Plugin.Context)

	def _Changed(self):
		self.PureVirtual('_Changed')



class StringMatchSetting(SettingItem):
	def _Init(self):
		self.Widget = gtk.Entry()
		self.Widget.connect('changed', self.Changed)

	def _Read(self):
		self.Widget.set_text(self.Setting.Value)

	def _Changed(self):
		self.Setting.Value = self.Widget.get_text()

class FileSetting(SettingItem):
	def _Init(self):
		self.Widget = gtk.HBox()
		self.Entry = gtk.Entry()
		self.Open = gtk.Button()
		self.Open.set_image(gtk.image_new_from_stock(
			gtk.STOCK_OPEN, gtk.ICON_SIZE_BUTTON))
		self.Open.connect('clicked', self.OpenFileChooser)
		self.Entry.connect('changed', self.Changed)
		self.Widget.pack_start(self.Entry)
		self.Widget.pack_end(self.Open, False, False)
	
	def CreateFilter(self):
		filter = gtk.FileFilter()
		if len(self.Setting.Hints) > 1:
			if self.Setting.Hints[1] == 'image':
				filter.set_name('Images')
				filter.add_pattern("*.png")
				filter.add_pattern("*.jpg")
				filter.add_pattern("*.jpeg")
				filter.add_pattern("*.svg")
			else:
				filter.add_pattern("*.*")
		else:
			filter.set_name('File')

		return filter

	def CheckFileType(self, filename):
		ext = filename.split(".")[-1]
		if len(self.Setting.Hints) > 1:
			if self.Setting.Hints[1] == 'image':
				return CheckFeature(self.Setting.Plugin.Context, 'imageext:' + ext)
		
		return True
			
	
	def OpenFileChooser(self, widget):
		b = (gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL, gtk.STOCK_OPEN, gtk.RESPONSE_OK)
		chooser = gtk.FileChooserDialog(title='Open file..', parent=mainWin, buttons=b)
		
		if os.path.exists(self.Setting.Value):
			chooser.set_filename(self.Setting.Value)
		else:
			chooser.set_current_folder(os.environ.get("HOME"))
		chooser.set_filter(self.CreateFilter())
		ret = chooser.run()
		
		filename = chooser.get_filename()
		chooser.destroy()
		if ret == gtk.RESPONSE_OK:
			if self.CheckFileType(filename):
				self.Entry.set_text(filename)

	def _Read(self):
		self.Entry.set_text(self.Setting.Value)

	def _Changed(self):
		self.Setting.Value = self.Entry.get_text()

class EnumSetting(SettingItem):
	def _Init(self):
		self.Widget = gtk.combo_box_new_text()
		for name in self.Setting.Info[2].keys():
			self.Widget.append_text(name)
		self.Widget.connect('changed', self.Changed)

	def _Read(self):
		index = 0
		for name, value in self.Setting.Info[2].items():
			if self.Setting.Value == value:
				break
			index = index + 1
		self.Widget.set_active(index)

	def _Changed(self):
		active = self.Widget.get_active_text()
		self.Setting.Value = self.Setting.Info[2][active]

class BoolSetting(SettingItem):
	def _Init(self):
		self.Custom = True
		self.Widget = gtk.HBox()
		self.CheckButton = gtk.CheckButton(self.Setting.ShortDesc)
		self.Widget.pack_start(self.CheckButton, True, True)
		self.Widget.pack_start(self.Reset, False, False)
		self.CheckButton.connect('toggled', self.Changed)

	def _Read(self):
		self.CheckButton.set_active(self.Setting.Value)

	def _Changed(self):
		self.Setting.Value = self.CheckButton.get_active()

class IntFloatSetting(SettingItem):
	def _Init(self):
		inc = 1
		if self.Setting.Type == 'Int':
			inc = 1
		else:
			inc = self.Setting.Info[2]

		self.Adj = gtk.Adjustment(self.Setting.Value, self.Setting.Info[0], self.Setting.Info[1], inc, inc*10)
		self.Spin = gtk.SpinButton(self.Adj)
		
		if self.Setting.Type == 'Float':
			self.Spin.set_digits(4)
		
		self.Scale = gtk.HScale(self.Adj)
		self.Scale.props.draw_value = False
		self.Adj.connect('value-changed', self.Changed)

	def Attach(self, Table, row):
		Table.attach(self.Label, 0, 1, row, row+1, gtk.FILL, TDef, TXp, TYp)
		Table.attach(self.Scale, 1, 2, row, row+1, TDef, TDef, TXp, TYp)
		Table.attach(self.Spin, 2, 3, row, row+1, gtk.FILL, TDef, TXp, TYp)
		Table.attach(self.Reset, 99, 100, row, row+1, 0, TDef, TXp, TYp)

	def _Read(self):
		self.Adj.set_value(self.Setting.Value)

	def _Changed(self):
		self.Setting.Value = self.Adj.get_value()

class ColorSetting(SettingItem):
	def _Init(self):
		self.Widget = gtk.ColorButton()
		self.Widget.set_use_alpha(True)
		self.Widget.connect('color-set', self.Changed)

	def _Read(self):
		col = gdk.Color()
		col.red = self.Setting.Value[0]
		col.green = self.Setting.Value[1]
		col.blue = self.Setting.Value[2]
		self.Widget.set_color(col)
		self.Widget.set_alpha(self.Setting.Value[3])

	def _Changed(self):
		col = self.Widget.get_color()
		alpha = self.Widget.get_alpha()
		self.Setting.Value = [col.red, col.green, col.blue, alpha]

class MultiListSetting(SettingItem):
	def _Init(self):
		self.Widget = gtk.VBox()
		self.Custom = True
		self.Settings = self.Setting # self.Setting is a list in this case
		
		types, cols = self.ListInfo()
		self.Types = types
		self.Store = gtk.ListStore(*types)
		self.View = gtk.TreeView(self.Store)
		self.View.set_headers_visible(True)
		for col in cols:
			self.View.insert_column_with_attributes(-1, col[0], col[1], **col[2])
		self.Store.connect('row-deleted', self.Changed)
		self.Store.connect('rows-reordered', self.Changed)
		self.Select = self.View.get_selection()
		self.Select.set_mode(gtk.SELECTION_MULTIPLE)

		self.Widget.set_border_width(5)
		self.Widget.set_spacing(5)
		self.Widget.set_size_request(-1, 150)
		self.Scroll = gtk.ScrolledWindow()
		self.Scroll.props.hscrollbar_policy = gtk.POLICY_NEVER
		self.Scroll.props.hscrollbar_policy = gtk.POLICY_AUTOMATIC
		self.Scroll.add(self.View)
		self.Widget.pack_start(self.Scroll, True, True)
		
		buttonBox = gtk.HBox(False)
		buttonBox.set_spacing(5)
		self.Widget.pack_start(buttonBox, False, False)
		buttonTypes = ((gtk.STOCK_ADD, self.Add),
				 (gtk.STOCK_DELETE, self.Delete), 
				 (gtk.STOCK_EDIT, self.Edit),
				 (gtk.STOCK_GO_UP, self.MoveUp), 
				 (gtk.STOCK_GO_DOWN, self.MoveDown),)
		for type in buttonTypes:
			b = gtk.Button(type[0])
			b.set_use_stock(True)
			buttonBox.pack_start(b, False, False)
			b.connect('clicked', type[1])
		buttonBox.pack_end(self.Reset, False, False)

	def ColChanged(self, *args, **kwargs):
		if self.Blocked <= 0:
			self._ColChanged(*args, **kwargs)
			Write(self.Settings[0].Plugin.Context)

	def Changed(self, *args, **kwargs):
		if self.Blocked <= 0:
			self._Changed()
			Write(self.Settings[0].Plugin.Context)

	def DoReset(self, foo):
		for setting in self.Settings:
			setting.Reset()
		Write(self.Setting[0].Plugin.Context)
		self.Read()

	def MakeLabel(self):
		pass
	
	def Add(self, b):
		values = self._Edit()
		if values is not None:
			self.Block()
			iter = self.Store.append()
			self.UnBlock()
			col = 0
			for value in values:
				self.SetIterValue(iter, col, value)
				col += 1
			self.Changed()

	def Delete(self, b):
		selectedRows = self.Select.get_selected_rows()[1]
		for path in selectedRows:
			iter = self.Store.get_iter(path)
			self.Store.remove(iter)

	def Edit(self, b):
		selectedRows = self.Select.get_selected_rows()[1]
		if len(selectedRows) == 1:
			iter = self.Store.get_iter(selectedRows[0])
			values = []
			for col in range(len(self.Settings)):
				value = self.Store.get(iter, col)[0]
				values.append(value)
			values = self._Edit(values)
			if values != None:
				col = 0
				for value in values:
					self.SetIterValue(iter, col, value)
					col += 1
				self.Changed()

	def MoveUp(self, b):
		selectedRows = self.Select.get_selected_rows()[1]
		if len(selectedRows) == 1:
			iter = self.Store.get_iter(selectedRows[0])
			prev = self.Store.get_iter_first()
			if not self.Store.get_path(prev) == self.Store.get_path(iter):
				while prev is not None and not self.Store.get_path(self.Store.iter_next(prev)) == self.Store.get_path(iter):
					prev = self.Store.iter_next(prev)
				self.Store.swap(iter, prev)

	def MoveDown(self, b):
		selectedRows = self.Select.get_selected_rows()[1]
		if len(selectedRows) == 1:
			iter = self.Store.get_iter(selectedRows[0])
			next = self.Store.iter_next(iter)
			if next is not None:
				self.Store.swap(iter, next)

	def ListInfo(self):
		types = []
		cols = []
		col = 0
		for setting in self.Settings:
			if setting.Info[0] == "String" or setting.Info[0] == "Match":
				types.append(gobject.TYPE_STRING)
			elif setting.Info[0] == "Int":
				types.append(gobject.TYPE_INT)
			elif setting.Info[0] == "Float":
				types.append(gobject.TYPE_FLOAT)
			
			renderer = gtk.CellRendererText()
			renderer.connect("edited", self.ColChanged, col)
			cols.append((setting.ShortDesc, renderer, {'text':col, 'editable':True}))
			col += 1

		return types, cols

	def _Read(self):
		self.Store.clear()
		iters = []
		for values in self.Settings[0].Value:
			iters.append(self.Store.append())

		row = 0
		for iter in iters:
			for j in range(len(self.Settings)):
				setting = self.Settings[j]
				value = setting.Value[row]
				self.Store.set(iter, j, value)
			row += 1

	def _Edit(self, values=None):
		dlg = gtk.Dialog("Edit", mainWin)
		dlg.add_button(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL)
		dlg.add_button(gtk.STOCK_OK, gtk.RESPONSE_OK).grab_default()
		dlg.set_default_response(gtk.RESPONSE_OK)
		table = gtk.Table()
		dlg.vbox.pack_start(table)

		row = 0
		widgets = []
		for setting in self.Settings:
			if self.Types[row] == gobject.TYPE_STRING:
				label = gtk.Label(setting.ShortDesc)
				entry = gtk.Entry()
				if values != None:
					entry.set_text(values[row])
				table.attach(label, 0, 1, row, row+1, xpadding=5)
				table.attach(entry, 2, 3, row, row+1, xpadding=5)
				widgets.append(entry)
			elif self.Types[row] == gobject.TYPE_INT or self.Types[row] == gobject.TYPE_FLOAT:
				label = gtk.Label(setting.ShortDesc)
				inc = 0
				if setting.Info[0] == 'Int':
					inc = 1
				else:
					inc = setting.Info[1][2]
				value = 0
				if values != None:
					value = values[row]
				adjustment = gtk.Adjustment(value, setting.Info[1][0], setting.Info[1][1], inc, inc*10)
				spin = gtk.SpinButton(adjustment)
				if setting.Info[0] == 'Float':
					spin.set_digits(4)
				scale = gtk.HScale(adjustment)
				scale.props.draw_value = False
				table.attach(label, 0, 1, row, row+1, xpadding=5)
				table.attach(scale, 2, 3, row, row+1, xpadding=5)
				table.attach(spin, 3, 4, row, row+1, xpadding=5)
				widgets.append(adjustment)
			row += 1

		dlg.vbox.show_all()
		ret = dlg.run()
		dlg.destroy()

		if ret == gtk.RESPONSE_OK:
			values = []
			row = 0
			for type in self.Types:
				if type == gobject.TYPE_STRING:
					value = widgets[row].get_text()
					values.append(value)
				elif type == gobject.TYPE_INT:
					value = int(widgets[row].get_value())
					values.append(value)
				elif type == gobject.TYPE_FLOAT:
					value = widgets[row].get_value()
					values.append(value)
				row += 1
			return values

		return None

	def SetIterValue(self, iter, col, value):
		if self.Types[col] == gobject.TYPE_STRING:
			self.Store.set(iter, col, value)
		elif self.Types[col] == gobject.TYPE_INT:
			self.Store.set(iter, col, int(value))
		elif self.Types[col] == gobject.TYPE_FLOAT:
			self.Store.set(iter, col, float(value))

	def _ColChanged(self, obj, path, value, col):
		iter = self.Store.get_iter_from_string(path)
		self.SetIterValue(iter, col, value)
		self._Changed()

	def _Changed(self):
		col = 0
		for setting in self.Settings:
			iter = self.Store.get_iter_first()
			values = []
			while iter:
				value = self.Store.get(iter, col)[0]
				values.append(value)
				iter = self.Store.iter_next(iter)
			setting.Value = values
			col += 1

	def Attach(self, table, row):
		table.attach(self.Widget, 0, 100, row, row+1, xpadding=5)

class ListSetting(SettingItem):
	def _Init(self):
		self.Widget = gtk.Frame(self.Setting.ShortDesc)
		self.Custom = True
		
		info = self._ListInfo()
		self.Store = gtk.ListStore(*info[0])
		self.View = gtk.TreeView(self.Store)
		if len(info[0]) == 1:
			self.View.set_headers_visible(False)
		for i in info[1]:
			self.View.insert_column_with_attributes(-1, i[1], i[0], **i[2])
		self.Store.connect('row-changed', self.Changed)
		self.Store.connect('row-deleted', self.Changed)
		self.Store.connect('row-inserted', self.Changed)
		self.Store.connect('rows-reordered', self.Changed)
		self.Select = self.View.get_selection()
		self.Select.set_mode(gtk.SELECTION_MULTIPLE)

		box = gtk.VBox()
		box.set_border_width(5)
		box.set_spacing(5)
		self.Widget.add(box)
		self.Scroll = gtk.ScrolledWindow()
		self.Scroll.props.hscrollbar_policy = gtk.POLICY_NEVER
		self.Scroll.props.hscrollbar_policy = gtk.POLICY_AUTOMATIC
		self.Scroll.add(self.View)
		box.pack_start(self.Scroll, True, True)
		
		buttonBox = gtk.HBox(False)
		buttonBox.set_spacing(5)
		box.pack_start(buttonBox, False, False)
		buttonTypes = ((gtk.STOCK_ADD, self.Add),
				 (gtk.STOCK_DELETE, self.Delete), 
				 (gtk.STOCK_EDIT, self.Edit),
				 (gtk.STOCK_GO_UP, self.MoveUp), 
				 (gtk.STOCK_GO_DOWN, self.MoveDown),)
		for type in buttonTypes:
			b = gtk.Button(type[0])
			b.set_use_stock(True)
			buttonBox.pack_start(b, False, False)
			b.connect('clicked', type[1])
		buttonBox.pack_end(self.Reset, False, False)

	def Add(self, b):
		value = self._Edit()
		if value is not None:
			self.Block()
			Iter = self.Store.append()
			self.UnBlock()
			self._ListSet(Iter, value)

	def Delete(self, b):
		selectedRows = self.Select.get_selected_rows()[1]
		for path in selectedRows:
			iter = self.Store.get_iter(path)
			self.Store.remove(iter)

	def Edit(self, b):
		selectedRows = self.Select.get_selected_rows()[1]
		if len(selectedRows) == 1:
			iter = self.Store.get_iter(selectedRows[0])
			value = self._Edit(self._ListGet(iter))
			if value is not None:
				self._ListSet(iter, value)

	def MoveUp(self, b):
		selectedRows = self.Select.get_selected_rows()[1]
		if len(selectedRows) == 1:
			iter = self.Store.get_iter(selectedRows[0])
			prev = self.Store.get_iter_first()
			if not self.Store.get_path(prev) == self.Store.get_path(iter):
				while prev is not None and not self.Store.get_path(self.Store.iter_next(prev)) == self.Store.get_path(iter):
					prev = self.Store.iter_next(prev)
				self.Store.swap(iter, prev)

	def MoveDown(self, b):
		selectedRows = self.Select.get_selected_rows()[1]
		if len(selectedRows) == 1:
			iter = self.Store.get_iter(selectedRows[0])
			next = self.Store.iter_next(iter)
			if next is not None:
				self.Store.swap(iter, next)

	def _ListInfo(self):
		self.PureVirtual('_ListInfo')

	def _Read(self):
		self.Store.clear()
		for value in self.Setting.Value:
			iter = self.Store.append()
			self._ListSet(iter, value)

	def _ListSet(self, iter, value):
		self.PureVirtual('_ListRead')

	def _ListGet(self, iter):
		self.PureVirtual('_ListGet')

	def _Edit(self, d, value = None):
		self.PureVirtual('_Edit')

	def _Changed(self):
		values = []
		iter = self.Store.get_iter_first()
		while iter:
			values.append(self._ListGet(iter))
			iter = self.Store.iter_next(iter)
		self.Setting.Value = values

	def Attach(self, table, row):
		table.attach(self.Widget, 0, 100, row, row+1, xpadding=5)

class StringMatchListSetting(ListSetting):
	def _ListInfo(self):
		return (gobject.TYPE_STRING, ), [(gtk.CellRendererText(), "Value (%s)" % self.Setting.Info[0], {'text':0})]

	def _ListSet(self, iter, value):
		self.Store.set(iter, 0, value)

	def _ListGet(self, iter):
		return self.Store.get(iter, 0)[0]

	def _Edit(self, value=None):
		dlg = gtk.Dialog("Edit %s" % self.Setting.ShortDesc, mainWin)
		dlg.add_button(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL)
		dlg.add_button(gtk.STOCK_OK, gtk.RESPONSE_OK).grab_default()
		dlg.set_default_response(gtk.RESPONSE_OK)
		dlg.vbox.pack_start(gtk.Label("Value(%s) for %s:" % (self.Setting.Info[0], self.Setting.ShortDesc)))
		entry = gtk.Entry()
		entry.props.activates_default = True
		if value is not None:
			entry.set_text(value)
		dlg.vbox.pack_start(entry)
		dlg.vbox.show_all()
		ret = dlg.run()
		dlg.destroy()

		if ret == gtk.RESPONSE_OK:
			return entry.get_text()
		return None

class IntDescListSetting(SettingItem):
	def _Init(self):
		self.Widget = gtk.Frame(self.Setting.ShortDesc)
		self.Table = gtk.Table()
		self.Custom = True
		
		row = 0
		col = 0
		self.Checks = []
		for key in self.Setting.Info[1][2].keys():
			box = gtk.CheckButton(key)
			self.Checks.append((key, box))
			self.Table.attach(box, col, col+1, row, row+1, TDef, TDef, TXp, TYp)
			box.connect('toggled', self.Changed)
			col = col+1
			if (col >=  3):
				col = 0
				row = row+1
		
		self.HBox = gtk.HBox()
		self.VBox = gtk.VBox()
		self.HBox.pack_start(self.VBox, False, False)
		self.HBox.pack_start(self.Table, True, True)
		self.VBox.pack_start(self.Reset, False, False)
		self.Widget.add(self.HBox)

	def _Read(self):
		for key, box in self.Checks:
			box.set_active(False)
		for setVal in self.Setting.Value:
			for key, box in self.Checks:
				if setVal == self.Setting.Info[1][2][key]:
					box.set_active(True)

	def _Changed(self):
		values = []
		for key, box in self.Checks:
			if box.get_active():
				values.append(self.Setting.Info[1][2][key])
		self.Setting.Value = values
	
	def Attach(self, table, row):
		table.attach(self.Widget, 0, 100, row, row+1, xpadding = 5)

class IntFloatListSetting(ListSetting):
	def _ListInfo(self):
		return (gobject.TYPE_STRING, ), [(gtk.CellRendererText(), 
			"Value (%s)" % self.Setting.Info[0], {'text':0})]

	def _ListSet(self, Iter, v):
		self.Store.set(Iter, 0, str(v))

	def _ListGet(self, Iter):
		return eval(self.Store.get(Iter, 0)[0])

	def _Edit(self, value = None):
		dlg = gtk.Dialog("Edit %s" % self.Setting.ShortDesc, mainWin)
		dlg.add_button(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL)
		dlg.add_button(gtk.STOCK_OK, gtk.RESPONSE_OK).grab_default()
		dlg.set_default_response(gtk.RESPONSE_OK)
		dlg.vbox.pack_start(gtk.Label("Value(%s) for %s:" % (self.Setting.Info[0], self.Setting.ShortDesc)))
		box = gtk.HBox()
		dlg.vbox.pack_start(box)
		
		val = self.Setting.Info[1][0]
		if value is not None:
			val = value
		
		if self.Setting.Info[0] == 'Int':
			inc = 1
		else:
			inc = self.Setting.Info[1][2]
		
		adj = gtk.Adjustment(val, 
				self.Setting.Info[1][0], self.Setting.Info[1][1], 
				inc, inc*10)
		spin = gtk.SpinButton(adj)
		if self.Setting.Info[0] == 'Float':
			spin.set_digits(4)
		scale = gtk.HScale(adj)
		scale.props.draw_value = False
		
		box.pack_start(scale, True, True)
		box.pack_start(spin, False, False)
		
		dlg.vbox.show_all()
		ret = dlg.run()
		dlg.destroy()

		if ret == gtk.RESPONSE_OK:
			return adj.get_value()
		return None

def MakeSetting(setting):
	if setting.Type == 'String' or setting.Type == 'Match':
		if len(setting.Hints) > 0 and setting.Hints[0] == 'file':
			return FileSetting(setting)
		else:
			return StringMatchSetting(setting)
	elif setting.Type == 'Bool':
		return BoolSetting(setting)
	elif setting.Type == 'Int' and len(setting.Info[2].keys()) > 0:
		return EnumSetting(setting)
	elif setting.Type == 'Float' or setting.Type == 'Int':
		return IntFloatSetting(setting)
	elif setting.Type == 'Color':
		return ColorSetting(setting)
	elif setting.Type == 'List':
		if setting.Info[0] == 'String' or setting.Info[0] == 'Match':
			return StringMatchListSetting(setting)
		elif setting.Info[0] == 'Int':
			if len(setting.Info[1][2]) > 0:
				return IntDescListSetting(setting)
			else:
				return IntFloatListSetting(setting)
		elif setting.Info[0] == 'Float':
			return IntFloatListSetting(setting)
		else:
			raise TypeError, "Unhandled list type %s for %s"%(setting.Info[0], setting.Name)
	return None


def SettingSortCompare(v1, v2):
	return cmp(v1.Plugin.Ranking[v1.Name], v2.Plugin.Ranking[v2.Name])

def FilterSettings(settings, filter):
	if filter == None:
		return settings

	filteredSettings = []

	for setting in settings:
		name = setting.ShortDesc.lower()
		if name.find(filter) != -1:
			filteredSettings.append(setting)

	return filteredSettings

def HasOnlyType(settings, type):
	empty = True
	for setting in settings:
			if not setting.Name == '____plugin_enabled':
				empty = False
				if setting.Type != type:
					return False
	return not empty

class SubGroupArea:
	def __init__(self, name, subGroup, filter=None):
		#settings = sum((v.values() for v in [subGroup.Display]+[subGroup.Screens[CurrentScreenNum]]), [])
		settings = FilterSettings(sorted(sum((v.values() for v in [subGroup.Display]+[subGroup.Screens[CurrentScreenNum]]), []), SettingSortCompare), filter)
		if name == '':
			self.Widget = gtk.Table()
			self.Child = self.Widget
		else:
			self.Widget = gtk.Frame()
			self.Expander = gtk.Expander(name)
			self.Widget.add(self.Expander)
			self.Expander.set_expanded(False)
			self.Child = gtk.Table()
			self.Expander.add(self.Child)

			# create a special widget for list subGroups
			if HasOnlyType(settings, 'List'):
				multiList = MultiListSetting(settings)
				multiList.Read()
				multiList.Attach(self.Child, 0)
				self.Empty = False
				self.Expander.set_expanded(True)

				return # exit earlier to avoid unneeded logic's
		
		self.Empty = True
		row = 0
		for setting in settings:
			if not setting.Name == '____plugin_enabled':
				set = MakeSetting(setting)
				if set is not None:
					set.Read()
					set.Attach(self.Child, row)
					row = row+1
					self.Empty = False

		if name != '' and row < 4: # ahi hay magic numbers!
			self.Expander.set_expanded(True)

class Page(object):
	def __init__(self, name):
		self.Widget = gtk.VBox()
		self.SetContainer = gtk.VBox()
		
		scroll = gtk.ScrolledWindow()
		scroll.props.hscrollbar_policy = gtk.POLICY_NEVER
		scroll.props.vscrollbar_policy = gtk.POLICY_AUTOMATIC
		
		view = gtk.Viewport()
		view.set_border_width(5)
		view.set_shadow_type(gtk.SHADOW_NONE)
		
		scroll.add(view)
		view.add(self.SetContainer)
		self.Widget.pack_start(scroll, True, True)
		
		self.Empty = True


class GroupPage(Page):
	def __init__(self, name, group, filter=None):
		super(GroupPage, self).__init__(name)

		if (group.has_key('')):
			sga = SubGroupArea('', group[''], filter)
			if not sga.Empty:
				self.SetContainer.pack_start(sga.Widget, False, False)
				self.Empty = False

		for subGroup in group.keys():
			if not subGroup == '':
				sga = SubGroupArea(subGroup, group[subGroup], filter)
				if not sga.Empty:
					self.SetContainer.pack_start(sga.Widget, False, False)
					self.Empty = False

def HandlePluginConflicts(conflicts):
	if len(conflicts) == 0:
		return True

	dlg = gtk.MessageDialog(parent = mainWin, flags = gtk.DIALOG_MODAL, type = gtk.MESSAGE_WARNING, buttons = gtk.BUTTONS_OK_CANCEL)
	for conflict in conflicts:
		if conflict[0] == 'ConflictFeature':
			# see if we can deactivate the plugin
			# mentioned in c[2]
			msg = "Plugin <b>%s</b> provides feature <b>%s</b> which is also provided " +\
				  "by the plugin you are trying to enable.\n" +\
				  "Click OK to disable plugin <b>%s</b>, or Cancel to stop trying to enable this plugin."
			msg = msg % (conflict[2][0].ShortDesc, conflict[1], conflict[2][0].ShortDesc)
			
			dlg.set_markup(msg)
			dlg.show_all()
			ret = dlg.run()
			dlg.destroy()

			if ret == gtk.RESPONSE_OK:
				disableConflicts = conflict[2][0].DisableConflicts
				if HandlePluginConflicts(disableConflicts):
					conflict[2][0].Enabled = False
				else:
					return False
			else:
				return False

		elif conflict[0] == 'ConflictPlugin':
			# see if we can deactivate the plugin
			# mentioned in c[2]
			msg = "Plugin <b>%s</b> conflicts with the plugin you are trying to enable.\n" +\
				  "Click OK to disable plugin <b>%s</b>, or Cancel to stop trying to enable this plugin."
			msg = msg % (conflict[2][0].ShortDesc, conflict[2][0].ShortDesc)
			
			dlg.set_markup(msg)
			dlg.show_all()
			ret = dlg.run()
			dlg.destroy()
			if ret == gtk.RESPONSE_OK:
				disableConflicts = conflict[2][0].DisableConflicts
				if HandlePluginConflicts(disableConflicts):
					conflict[2][0].Enabled = False
				else:
					return False
			else:
				return False
		
		elif conflict[0] == 'RequiresFeature':
			# we need to activate one of c[2]
			msg = "The plugin you are trying to enable requires feature <b>%s</b> which " +\
				  "is provided by the following plugins.\n" +\
				  "Click OK to enable the selected plugin or Cancel to stop trying to enable this plugin."
			msg = msg % conflict[1]
			
			dlg.set_markup(msg)
			cmb = gtk.combo_box_new_text()
			dlg.vbox.pack_start(cmb, False, False)
			for plugin in conflict[2]:
				cmb.append_text(plugin.ShortDesc)
			cmb.set_active(0)
			dlg.show_all()
			ret = dlg.run()
			retVal = cmb.get_active_text()
			dlg.destroy()
			
			if ret == gtk.RESPONSE_OK:
				for plugin in conflict[2]:
					if plugin.ShortDesc == retVal:
						enableConflicts = plugin.EnableConflicts
						if HandlePluginConflicts(enableConflicts):
							plugin.Enabled = True
						else:
							return False
						break
			else:
				return False

		elif conflict[0] == 'RequiresPlugin':
			msg = "The plugin you are trying to enable requires the plugin <b>%s</b>.\n" +\
				  "Click OK to enable <b>%s</b> or Cancel to stop trying to enable this plugin."
			msg = msg % (conflict[2][0].ShortDesc, conflict[2][0].ShortDesc)
			
			dlg.set_markup(msg)
			dlg.show_all()
			ret = dlg.run()
			dlg.destroy()
			
			if ret ==  gtk.RESPONSE_OK:			
				enableConflicts = conflict[2][0].EnableConflicts
				if HandlePluginConflicts(enableConflicts):
					conflict[2][0].Enabled = True
				else:
					return False
			else:
				return False

		elif conflict[0] == 'FeatureNeeded':
			pluginList = ', '.join("\"%s\"" % plugin.ShortDesc for plugin in conflict[2])
			msg = "The plugin you are trying to disable provides the feature <b>%s</b> " +\
				  "which is required by the plugins <b>%s</b>.\n" +\
				  "Click OK to disable these plugins or Cancel to stop trying to disable this plugin."
			msg = msg % (conflict[1], pluginList) 
			
			dlg.set_markup(msg)
			dlg.show_all()
			ret = dlg.run()
			dlg.destroy()
			
			if ret == gtk.RESPONSE_OK:
				for plugin in conflict[2]:
					disableConflicts = plugin.DisableConflicts
					if HandlePluginConflicts(disableConflicts):
						plugin.Enabled = False
					else:
						return False
			else:
				return False

		elif conflict[0] == 'PluginNeeded':
			pluginList = ', '.join("\"%s\"" % plugin.ShortDesc for plugin in conflict[2])
			msg = "The plugin you are trying to disable is required by the plugins <b>%s</b>.\n" +\
				  "Click OK to disable these plugins or Cancel to stop trying to disable this plugin."
			msg = msg % plist
			
			dlg.set_markup(msg)
			dlg.show_all()
			ret = dlg.run()
			dlg.destroy()

			if ret == gtk.RESPONSE_OK:
				for plugin in conflict[2]:
					disableConflicts = p.DisableConflicts
					if HandlePluginConflicts(disableConflicts):
						plugin.Enabled = False
					else:
						return False
			else:
				return False

	return True

class ActionItem(SettingItem):
	pass

class ActionPage:
	def __init__(self, plugin, filter = None):
		self.EdgeList = ['None', 'TopLeft', 'Top', 'TopRight', 'Left', 'Right', 'BottomLeft', 'Bottom', 'BottomRight']
		self.Widget = gtk.VBox()
		self.Plugin = plugin
		self.Filter = filter
		self.Context = context
		self.Scroll = gtk.ScrolledWindow()
		self.Scroll.props.hscrollbar_policy = gtk.POLICY_AUTOMATIC
		self.Scroll.props.vscrollbar_policy = gtk.POLICY_AUTOMATIC
		self.Store = gtk.TreeStore(
				gobject.TYPE_STRING, 	#0-Name
				gobject.TYPE_UINT, 		#1-Key
				gobject.TYPE_UINT, 		#2-KeyMods
				gobject.TYPE_STRING, 	#3-Button
				gobject.TYPE_STRING, 	#4-Edges
				gobject.TYPE_BOOLEAN, 	#5-Visible/Editable
				gobject.TYPE_BOOLEAN, 	#6-Bell
				gobject.TYPE_BOOLEAN,   #7-KeyPossible
				gobject.TYPE_BOOLEAN,   #8-ButPossible
				gobject.TYPE_BOOLEAN,   #9-EdgePossible
				gobject.TYPE_BOOLEAN,   #10-BellPossible
				gobject.TYPE_STRING, 	#11-group
				gobject.TYPE_STRING, 	#12-subgroup
				gobject.TYPE_STRING, 	#13-setting
				gobject.TYPE_STRING, 	#14-plugin
				gobject.TYPE_STRING, 	#15-disp/scn str XXX
				)
		
		self.TreeView = gtk.TreeView(self.Store)
		self.TreeView.set_headers_visible(True)
		# Name
		self.TreeView.insert_column_with_attributes(-1, 'Name', gtk.CellRendererText(), text=0)
		# Key
		keyRenderer = gtk.CellRendererAccel()
		keyRenderer.connect('accel-edited', self.KeyEdited)
		keyRenderer.connect('accel-cleared', self.KeyCleared)
		self.TreeView.insert_column_with_attributes(-1, 'Key', keyRenderer, accel_key=1, accel_mods=2, editable=7, visible=5, sensitive=7)
		# Button
		buttonRenderer = gtk.CellRendererText()
		buttonRenderer.connect('edited', self.ButtonEdited)
		self.TreeView.insert_column_with_attributes(-1, 'Button', buttonRenderer, text=3, editable=8, visible=5, sensitive=8)
		# Edges
		edgeRenderer = gtk.CellRendererText()
		self.TreeView.insert_column_with_attributes(-1, 'Screen Edge', edgeRenderer, text=4, visible=5, sensitive=9)
		# Bell -- may replace with one setting in general
		bellRenderer = gtk.CellRendererToggle()
		bellRenderer.props.xalign = 0
		bellRenderer.connect('toggled', self.BellEdited)
		self.TreeView.insert_column_with_attributes(-1, 'On System Bell', bellRenderer, activatable=10, visible=5, sensitive=10, active=6) 
		
		for col in self.TreeView.get_columns():
			col.set_resizable(True)
		
		self.Scroll.add(self.TreeView)
		self.Widget.pack_start(self.Scroll, True, True)
		self.Empty = True
		self.TreeView.connect('row-activated', self.Activated)
		
		self.Plugins = {}
		if plugin:
			self.DoGroups(plugin.Groups, None, plugin.Name)
		else:
			for plugin in Context.Plugins.values():
				pluginIter = self.Store.append(None)
				self.Store.set(pluginIter, 0, plugin.ShortDesc, 5, False, 7, False, 8, False, 9, False, 10, False)
				if not self.DoGroups(plugin.Groups, pluginIter, plugin.Name):
					self.Store.remove(pluginIter)
	
	def DoGroups(self, groupList, iter, pluginName):
		self.Plugins[pluginName] = {}
		pluginEmpty = True
		
		for groupName, group in groupList.items():
			groupEmpty = True
			groupIter = self.Store.append(iter)
			self.Store.set(groupIter, 0, groupName == '' and 'General' or groupName, 5, False, 7, False, 8, False, 9, False, 10, False)
			self.Plugins[pluginName][groupName] = {}
			
			for subGroupName, subGroup in group.items():
				if subGroupName != '':
					subGroupIter = self.Store.append(groupIter)
					self.Store.set(subGroupIter, 0, subGroupName, 5, False, 7, False, 8, False, 9, False, 10, False)
				self.Plugins[pluginName][groupName][subGroupName] = {}
				subGroupEmpty = True
				
				settings = sum((v.values() for v in [subGroup.Display]+[subGroup.Screens[CurrentScreenNum]]), [])
				settings = sorted(FilterSettings(settings, self.Filter), SettingSortCompare)
				for setting in settings:
					if setting.Type == 'Action':
						if subGroupName != '':
							i = self.Store.append(subGroupIter)
						else:
							i = self.Store.append(groupIter)

						key, mods = gtk.accelerator_parse(setting.Value[0])
						edges = 'None'
						if len(setting.Value[3]) > 0:
							edges = " | ".join(setting.Value[3])
						
						self.Store.set(i, 0, setting.ShortDesc, 1, key, 2, mods, 3, setting.Value[1], 4,
									   edges, 5, True, 6, setting.Value[2], 7, setting.Info[0], 8, setting.Info[1], 9,
									   setting.Info[3], 10, setting.Info[2], 11, groupName, 12, subGroupName, 13,
									   setting.Name, 14, pluginName)
						self.Plugins[pluginName][groupName][subGroupName][setting.Name] = setting
						
						groupEmpty = False
						subGroupEmpty = False
						pluginEmpty = False
						self.Empty = False
				
				if subGroupEmpty:
					if subGroupName != '':
						self.Store.remove(subGroupIter)
			if groupEmpty:
				self.Store.remove(groupIter)
		
		return not pluginEmpty
	
	def Activated(self, object, path, col):
		def ResetButton(object, setting, iter):
			if setting.Info[0]:
				keyEntry.set_text(setting.DefaultValue[0])
			if setting.Info[1]:
				buttonEntry.set_text(setting.DefaultValue[1])
			if setting.Info[2]:
				bellButton.set_active(setting.DefaultValue[2])
			if setting.Info[3]:
				children = edgeTable.get_children()
				edges = setting.DefaultValue[3]
				for checkBox in children:
					checkBox.set_active(False)
					for edge in edges:
						if checkBox.get_label() == edge:
							checkBox.set_active(True)
							break
							

		iter = self.Store.get_iter(path)
		store = self.Store.get(iter, 11, 12, 13, 14, 1, 2, 3, 4, 6)
		groupName, subGroupName, settingName, pluginName, key, keyModifier, button, edges, bell = store
		edges = edges.split(" | ")

		if subGroupName is None or groupName is None or settingName is None:
			if self.TreeView.row_expanded(path):
				self.TreeView.collapse_row(path)
			else:
				self.TreeView.expand_row(path, False)
			return

		setting = self.Plugins[pluginName][groupName][subGroupName][settingName]

		dlg = gtk.Dialog("Edit Action: %s" % setting.ShortDesc)
		dlg.add_button(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL)
		dlg.add_button(gtk.STOCK_OK, gtk.RESPONSE_OK).grab_default()
		dlg.set_default_response(gtk.RESPONSE_OK)
		table = gtk.Table()
		dlg.vbox.pack_start(table, False, False)
		
		# Key
		if setting.Info[0]:
			keyEntry = gtk.Entry()
			keyEntry.set_text(gtk.accelerator_name(key, keyModifier) or 'None')
			keyLabel = gtk.Label('Key')
			keyLabel.props.xalign = 0
			table.attach(keyLabel, 0, 1, 0, 1, TDef, TDef, TXp, TYp)
			table.attach(keyEntry, 1, 2, 0, 1, TDef, TDef, TXp, TYp)
		
		# Button
		if setting.Info[1]:
			buttonEntry = gtk.Entry()
			buttonEntry.set_text(button)
			buttonLabel = gtk.Label('Button')
			buttonLabel.props.xalign = 0
			table.attach(buttonLabel, 0, 1, 1, 2, TDef, TDef, TXp, TYp)
			table.attach(buttonEntry, 1, 2, 1, 2, TDef, TDef, TXp, TYp)
		
		# Edge
		if setting.Info[3]:
			edgeTable = gtk.Table()
			row = 0
			col = 0
			for e in self.EdgeList:
				if e == 'None':
					continue
				
				edgeCheck = gtk.CheckButton(e)
				if edges.count(e) > 0:
					edgeCheck.set_active(True)
				edgeTable.attach(edgeCheck, col, col+1, row, row+1, TDef, TDef, TXp, TYp)

				col += 1
				if col > 2:
					row += 1
					col = 0

				if (row == 1 and col > 0):
					col += 1
					
			edgeLabel = gtk.Label('Screen Edges')
			edgeLabel.props.xalign = 0
			table.attach(edgeLabel, 0, 1, 2, 3, TDef, TDef, TXp, TYp)
			table.attach(edgeTable, 1, 2, 2, 3, TDef, TDef, TXp, TYp)
		
		# Bell
		if setting.Info[2]:
			bellButton = gtk.CheckButton('On System Bell')
			bellButton.set_active(be)
			tabel.attach(bellButton, 0, 2, 3, 4, TDef, TDef, TXp, TYp)
		
		# Reset
		box = gtk.HBox()
		box.pack_start(MakeLabel('Reset To Defaults'), True, True)
		resetButton = gtk.Button()
		resetImage = gtk.Image()
		resetImage.set_from_stock(gtk.STOCK_CLEAR, gtk.ICON_SIZE_BUTTON)
		resetButton.set_image(resetImage)
		box.pack_end(resetButton, False, False)
		resetButton.connect('clicked', ResetButton, setting, iter)
		table.attach(box, 0, 2, 4, 5, TDef, TDef, TXp, TYp)
		
		dlg.show_all()
		resp = dlg.run()
		if setting.Info[0]:
			key = keyEntry.get_text()
		if setting.Info[1]:
			button = buttonEntry.get_text()
		if setting.Info[2]:
			bell = bellButton.get_active()
		if setting.Info[3]:
			children = edgeTable.get_children()
			edges = []
			for checkBox in children:
				if checkBox.get_active():
					edges.append(checkBox.get_label())
			edges = " | ".join(edges)
		
		dlg.destroy()
		if resp == gtk.RESPONSE_OK:
			if setting.Info[0]:
				akey, amods = gtk.accelerator_parse(key)
				self.Store.set(iter, 1, akey, 2, amods)
			if setting.Info[1]:
				self.Store.set(iter, 3, button)
			if setting.Info[2]:
				self.Store.set(iter, 6, bell)
			if setting.Info[3]:
				self.Store.set(iter, 4, edges)
			self.WriteSetting(iter)
	
	def WriteSetting(self, iter):
		store = self.Store.get(iter, 11, 12, 13, 14, 1, 2, 3, 4, 6)
		groupName, subGroupName, settingName, pluginName, key, keyModifier, button, edges, bell = store
		
		setting = self.Plugins[pluginName][groupName][subGroupName][settingName]
		realKey = gtk.accelerator_name(key, keyModifier)
		edges = edges.split(" | ")
		
		if CheckActionConflicts(setting, realKey, button, bell, edges):
			setting.Value = [realKey, button, bell, edges]
			Write(setting.Plugin.Context)
			
		realKey, button, bell, edges = setting.Value
		key, keyModifier = gtk.accelerator_parse(realKey)
		if len(edges) > 0:
			edges = " | ".join(setting.Value[3])
		else:
			edges = 'None'
		self.Store.set(iter, 1, key, 2, keyModifier, 3, button, 4, edges, 6, bell)
	
	def KeyEdited(self, obj, path, key, mods, code):
		iter = self.Store.get_iter_from_string(path)
		self.Store.set(iter, 1, key, 2, mods)
		self.WriteSetting(iter)
	
	def KeyCleared(self, obj, path):
		iter = self.Store.get_iter_from_string(path)
		self.Store.set(iter, 1, 0, 2, 0)
		self.WriteSetting(iter)
	
	def ButtonEdited(self, obj, path, val):
		iter = self.Store.get_iter_from_string(path)
		self.Store.set(iter, 3, val)
		self.WriteSetting(iter)
	
	def EdgeEdited(self, obj, path, val):
		iter = self.Store.get_iter_from_string(path)
		self.Store.set(iter, 4, val)
		self.WriteSetting(iter)
	
	def BellEdited(self, obj, path):
		iter = self.Store.get_iter_from_string(path)
		value = self.Store.get(iter, 6)[0]
		if value:
			value = False
		else:
			value = True
		self.Store.set(iter, 6, value)
		self.WriteSetting(iter)


def MakeLabel(value = None, wrap = 160):
	if value is not None:
		label = gtk.Label(value)
	else:
		label = gtk.Label()
	label.props.xalign = 0
	label.props.wrap_mode = gtk.WRAP_WORD
	label.set_line_wrap(True)
	label.set_size_request(wrap, -1)
	return label

class PluginClass:
	def __init__(self, plugin, main):
		self.Plugin = plugin
		self.LeftWidget = gtk.VBox(False, 10)
		self.LeftWidget.set_border_width(15)
		pluginLabel = MakeLabel()
		pluginLabel.set_markup("<span color='%s' size='large' weight='800'>%s</span>" % (main.BrightColor, plugin.ShortDesc))
		pluginImg = main.MakeImage(plugin, size = 64)
		filterLabel = MakeLabel()
		filterLabel.set_markup("<span color='%s' size='large' weight='800'>Filter</span>" % (main.BrightColor))
		filterEntry = gtk.Entry()
		filterEntry.connect("changed", self.FilterChanged)
		self.LeftWidget.pack_start(pluginImg, False, False)
		self.LeftWidget.pack_start(filterLabel, False, False)
		self.LeftWidget.pack_start(filterEntry, False, False)
		self.LeftWidget.pack_start(pluginLabel, False, False)
		infoLabelCont = gtk.HBox()
		infoLabelCont.set_border_width(10)
		self.LeftWidget.pack_start(infoLabelCont, False, False)
		infoLabel = MakeLabel(plugin.LongDesc, 180)
		infoLabelCont.pack_start(infoLabel, True, True)
		
		if plugin.Name != 'core':
			enableLabel = MakeLabel()
			enableLabel.set_markup("<span color='%s' size='large' weight='800'>%s</span>" % (main.BrightColor, 'Use This Plugin'))
			self.LeftWidget.pack_start(enableLabel, False, False)
			enableCheckCont = gtk.HBox()
			enableCheckCont.set_border_width(10)
			self.LeftWidget.pack_start(enableCheckCont, False, False)
			enableCheck = gtk.CheckButton()
			enableCheck.add(MakeLabel("Enable %s" % plugin.ShortDesc, 120))
			enableCheck.set_active(plugin.Enabled)
			enableCheckCont.pack_start(enableCheck, True, True)
			enableCheck.connect('toggled', self.EnablePlugin)
		
		backButton = gtk.Button(gtk.STOCK_GO_BACK)
		backButton.set_use_stock(True)
		self.LeftWidget.pack_end(backButton, False, False)
		backButton.connect('clicked', main.BackToMain)
		self.RightWidget = gtk.Notebook()
		
		for name, group in plugin.Groups.items():
			name = name or 'General'
			groupPage = GroupPage(name, group)
			if not groupPage.Empty:
				self.RightWidget.append_page(groupPage.Widget, gtk.Label(name))
		
		actionPage = ActionPage(plugin)
		if not actionPage.Empty:
			self.RightWidget.append_page(actionPage.Widget, gtk.Label('Actions'))
		self.Block = 0

	def FilterChanged(self, widget):
		filter = widget.get_text().lower()
		if filter == "":
			filter = None

		groups = []

		for name, group in self.Plugin.Groups.items():
			name = name or 'General'
			groupPage = GroupPage(name, group, filter)
			if not groupPage.Empty:
				groups.append((name, groupPage))

		for page in self.RightWidget.get_children():
			self.RightWidget.remove_page(self.RightWidget.page_num(page))
			page.destroy()

		for name, groupPage in groups:
			self.RightWidget.append_page(groupPage.Widget, gtk.Label(name))
		
		actionPage = ActionPage(self.Plugin, filter)
		if not actionPage.Empty:
			self.RightWidget.append_page(actionPage.Widget, gtk.Label('Actions'))

		self.RightWidget.show_all()

	def EnablePlugin(self, widget):
		if self.Block > 0:
			return
		self.Block += 1
		# attempt to resolve conflicts...
		conflicts = self.Plugin.Enabled and self.Plugin.DisableConflicts or self.Plugin.EnableConflicts
		if HandlePluginConflicts(conflicts):
			self.Plugin.Enabled = widget.get_active()
		else:
			widget.set_active(self.Plugin.Enabled)
		Write(self.Plugin.Context)
		self.Block = self.Block-1

class ProfileBackendPage:
	def __init__(self, main, context):
		self.Context = context
		self.Main = main
		self.MainWin = main.MainWin
		self.LeftWidget = gtk.VBox(False, 10)
		self.LeftWidget.set_border_width(15)
		self.RightWidget = gtk.Notebook()
		rightChild = gtk.VBox()
		rightChild.set_border_width(10)
		self.RightWidget.append_page(rightChild, gtk.Label('Profile & Backend'))

		# Left Pane
		self.DescLabel = MakeLabel()
		self.DescLabel.set_markup("<span color='%s' size='large' weight='800'>Backend &amp; Profile</span>" % main.BrightColor)
		self.DescImg = main.MakeImage(category="profiles", size = 64)
		self.LeftWidget.pack_start(self.DescImg, False, False)
		self.LeftWidget.pack_start(self.DescLabel, False, False)
		self.InfoLabelCont = gtk.HBox()
		self.InfoLabelCont.set_border_width(10)
		self.LeftWidget.pack_start(self.InfoLabelCont, False, False)
		self.InfoLabel = MakeLabel("Configure the backend and profile used by the Compiz Configuration System.", 180)
		self.InfoLabelCont.pack_start(self.InfoLabel, True, True)

		# Profiles
		profileBox = gtk.HBox()
		profileAdd = gtk.Button()
		profileAdd.set_image(gtk.image_new_from_stock(gtk.STOCK_ADD, gtk.ICON_SIZE_BUTTON))
		profileRemove = gtk.Button()
		profileRemove.set_image(gtk.image_new_from_stock(gtk.STOCK_REMOVE, gtk.ICON_SIZE_BUTTON))
		profileComboBox = gtk.combo_box_new_text()
		profileComboBox.set_sensitive(self.Context.CurrentBackend.ProfileSupport)
		profileComboBox.append_text("Default")
		for profile in self.Context.Profiles.values():
			profileComboBox.append_text(profile.Name)
		if self.Context.CurrentProfile.Name == '':
			profileComboBox.set_active(0)
		else:
			name = self.Context.CurrentProfile.Name
			index = self.Context.Profiles.values().index(self.Context.Profiles[name])
			profileComboBox.set_active(index+1)
		profileComboBox.connect("changed", self.ProfileChanged)
		profileAdd.connect("clicked", self.AddProfile, profileComboBox)
		profileRemove.connect("clicked", self.RemoveProfile, profileComboBox)
		profileBox.pack_start(profileComboBox, True, True)
		profileBox.pack_start(profileAdd, False, False)
		profileBox.pack_start(profileRemove, False, False)
		profileLabel = MakeLabel()
		profileLabel.set_markup("<span color='%s' size='large' weight='800'>Profile</span>" % self.Main.BrightColor)
		rightChild.pack_start(profileLabel, False, False, 5)
		rightChild.pack_start(profileBox, False, False, 5)

		# Backends
		backendBox = gtk.combo_box_new_text()
		for backend in self.Context.Backends.values():
			backendBox.append_text(backend.ShortDesc)
		name = self.Context.CurrentBackend.Name
		index = self.Context.Backends.values().index(self.Context.Backends[name])
		backendBox.set_active(index)
		backendBox.connect("changed", self.BackendChanged, profileComboBox)
		backendLabel = MakeLabel()
		backendLabel.set_markup("<span color='%s' size='large' weight='800'>Backend</span>" % self.Main.BrightColor)
		rightChild.pack_start(backendLabel, False, False, 5)
		rightChild.pack_start(backendBox, False, False, 5)

		# Integration
		integrationLabel = MakeLabel()
		integrationLabel.set_markup("<span color='%s' size='large' weight='800'>Integration</span>" % self.Main.BrightColor)
		integrationButton = gtk.CheckButton("Enable integration into the desktop environment")
		integrationButton.set_active(self.Context.Integration)
		integrationButton.set_sensitive(self.Context.CurrentBackend.IntegrationSupport)
		integrationButton.connect("toggled", self.IntegrationChanged)
		rightChild.pack_start(integrationLabel, False, False, 5)
		rightChild.pack_start(integrationButton, False, False, 5)		

		# Back Button
		self.BackButton = gtk.Button(gtk.STOCK_GO_BACK)
		self.BackButton.set_use_stock(True)
		self.BackButton.connect('clicked', self.Main.BackToMain)
		self.LeftWidget.pack_end(self.BackButton, False, False)
	
	def UpdateProfiles(self, widget, default = "Default"):
		self.Context.Read()

		widget.get_model().clear()
		widget.append_text("Default")
		for profile in self.Context.Profiles.values():
			widget.append_text(profile.Name)

		index = -1
		counter = 0
		for m in widget.get_model():
			if m[0] == default:
				index=counter
			counter += 1
		if index >= 0:
			widget.set_active(index)

	def IntegrationChanged(self, widget):
		value = widget.get_active()
		self.Context.Integration = value

	def ProfileChanged(self, widget):
		name = widget.get_active_text()
		if name == 'Default':
			self.Context.ResetProfile()
		else:
			self.Context.CurrentProfile = self.Context.Profiles[name]
		
		self.Context.Read()
		Write(self.Context)

	def AddProfile(self, widget, box):
		dlg = gtk.Dialog("Enter a profile name", self.MainWin, gtk.DIALOG_MODAL)
		dlg.add_button(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL)
		dlg.add_button(gtk.STOCK_OK, gtk.RESPONSE_OK)
		
		entry = gtk.Entry()
		label = gtk.Label("Please enter a name for the new profile:")
		dlg.vbox.pack_start(label, False, False, 5)
		dlg.vbox.pack_start(entry, False, False, 5)

		dlg.set_size_request(340, 120)
		dlg.show_all()
		ret = dlg.run()
		if ret == gtk.RESPONSE_OK:
			self.Context.CurrentProfile = ccs.Profile(self.Context, entry.get_text())
			self.UpdateProfiles(box, entry.get_text())
		dlg.destroy()
	
	def RemoveProfile(self, widget, box):
		name = box.get_active_text()
		if name != 'Default':
			self.Context.ResetProfile()
			self.Context.Profiles[name].Delete()
			self.UpdateProfiles(box)
	
	def BackendChanged(self, widget, box):
		shortDesc = widget.get_active_text()
		name = ""
		for backend in self.Context.Backends.values():
			if backend.ShortDesc == shortDesc:
				name = backend.Name
				break
		
		if name != "":
			self.Context.ResetProfile()
			self.Context.CurrentBackend = self.Context.Backends[name]
			# Causes some problems...
			#self.UpdateProfiles(box)
		else:
			raise Exception, "Backend not found."

def Quit(foo):
	gtk.main_quit()

class MainWinClass:
	def __init__(self, Context):
		self.Context = Context
		self.MainWin = gtk.Window()
		self.MainWin.connect("destroy", Quit)
		self.MainWin.set_default_size(960, 580)
		self.MainWin.set_title("CompizConfig Settings Manager")
		try:
			self.MainWin.set_icon (gdk.pixbuf_new_from_file(IconDir+"/apps/ccsm.svg"))
		except:
			pass
		# set up the Entry to get the BrightColor
		styleWidget = gtk.Entry()
		self.MainWin.add(styleWidget)
		styleWidget.realize()
		bc = styleWidget.style.bg[gtk.STATE_SELECTED]
		self.BrightColor = "#%.4x%.4x%.4x" % (bc.red, bc.green, bc.blue)
		self.MainWin.remove(styleWidget)
		styleWidget.destroy()
		
		# build the panes
		self.MainBox = gtk.HBox()
		self.MainWin.add(self.MainBox)
		self.LeftPane = gtk.Alignment()
		self.LeftPane.set_size_request(230, 520)
		self.RightPane = gtk.Alignment()
		self.RightPane.set_border_width(5)
		self.RightPane.props.yscale = 1
		self.RightPane.props.xscale = 1
		self.RightPane.props.xalign = 0
		self.RightPane.props.yalign = 0
		self.LeftPane.props.yscale = 1
		self.LeftPane.props.xscale = 1
		self.LeftPane.props.xalign = 0
		self.LeftPane.props.yalign = 0
		self.MainBox.pack_start(self.LeftPane, False, False)
		self.MainBox.pack_start(self.RightPane, True, True)
		self.Categories = {}
		self.PluginImages = {}
		self.RightVadj = 0.0
		
		for pluginName, plugin in self.Context.Plugins.items():
			self.PluginImages[pluginName] = self.MakeImage(plugin)
		
		for category in sorted(self.Context.Categories, self.CatSortCompare):
			self.Categories[category] = []
			for pluginName, plugin in self.Context.Plugins.items():
				if plugin.Category == category:
					self.Categories[category].append(plugin)
		
		self.BlockEnablePlugin = 0
		self.ResetMainWidgets()

	def ResetMainWidgets(self):
		pluginsVPort = gtk.Viewport()
		leftChild = gtk.VBox(False, 10)
		leftChild.set_border_width(15)
		
		# Filter
		filterLabel = MakeLabel()
		filterLabel.set_markup("<span color='%s' size='large' weight='800'>Filter</span>" % self.BrightColor)
		leftChild.pack_start(filterLabel, False, False)
		filterEntry = gtk.Entry()
		filterEntry.connect("changed", self.FilterTable)
		leftChild.pack_start(filterEntry, False, False)

		# Screens
		screenBox = gtk.combo_box_new_text()
		for screen in getScreens():
			screenBox.append_text("Screen %i" % screen)
		name = self.Context.CurrentBackend.Name
		screenBox.set_active(CurrentScreenNum)
		screenBox.connect("changed", self.ScreenChanged)
		screenLabel = MakeLabel()
		screenLabel.set_markup("<span color='%s' size='large' weight='800'>Screen</span>" % self.BrightColor)
		leftChild.pack_start(screenLabel, False, False)
		leftChild.pack_start(screenBox, False, False)

		# Information
		infoLabel = MakeLabel()
		infoLabel.set_markup("<span color='%s' size='large' weight='800'>Information</span>" % self.BrightColor)
		leftChild.pack_start(infoLabel, False, False)
		infoBox = gtk.VBox()
		infoBox.set_border_width(10)
		self.PluginDescription = MakeLabel(wrap = 180)
		self.PluginDescription.set_markup("")
		infoBox.pack_start(self.PluginDescription, False, False)
		leftChild.pack_start(infoBox, False, False)
		
		# Profiles and Backend
		profBackLabel = MakeLabel()
		profBackLabel.set_markup("<span color='%s' size='large' weight='800'>Backend &amp; Profile</span>" % self.BrightColor)
		profBackImage = gtk.Image()
		profBackImage.set_from_stock(gtk.STOCK_GO_FORWARD, gtk.ICON_SIZE_BUTTON)
		profBackButton = gtk.Button()
		profBackButton.connect("clicked", self.ShowProfileBackend)
		profBackButton.set_relief(gtk.RELIEF_NONE)
		profBackFrame = gtk.HBox()
		profBackFrame.pack_start(profBackLabel, False, False)
		profBackFrame.pack_end(profBackImage, False, False)
		profBackButton.add(profBackFrame)
		leftChild.pack_end(profBackButton, False, False)

		# Categories
		categoryBox = gtk.VBox()
		categoryBox.set_no_show_all(True)
		for category in sorted(self.Categories, self.CatSortCompare):
			name = category or 'Uncategorized'
			categoryToggleLabel = MakeLabel(name)
			categoryToggle = gtk.Button()
			categoryToggle.add(categoryToggleLabel)
			categoryToggle.connect("clicked", self.ToggleCategory, category)
			categoryBox.pack_start(categoryToggle, False, False)
		categoryLabel = MakeLabel()
		categoryLabel.set_markup("<span color='%s' size='large' weight='800'>Category</span>" % self.BrightColor)
		categoryImage = gtk.Image()
		categoryImage.set_from_stock(gtk.STOCK_GO_UP, gtk.ICON_SIZE_BUTTON)
		categoryButton = gtk.Button()
		categoryButton.connect("clicked", self.Expand, categoryBox)
		categoryButton.set_relief(gtk.RELIEF_NONE)
		categoryFrame = gtk.HBox()
		categoryFrame.pack_start(categoryLabel, False, False)
		categoryFrame.pack_end(categoryImage, False, False)
		categoryButton.add(categoryFrame)
		leftChild.pack_end(categoryButton, False, False)
		leftChild.pack_end(categoryBox, False, False)

		pluginsVPort.modify_bg(gtk.STATE_NORMAL, gtk.gdk.color_parse('#ffffff'))
		rightChild = gtk.ScrolledWindow()
		rightChild.props.hscrollbar_policy = gtk.POLICY_NEVER
		rightChild.props.vscrollbar_policy = gtk.POLICY_AUTOMATIC
		rightChild.set_size_request(280,-1)
		rightChild.add(pluginsVPort)
		self.BuildTable(pluginsVPort)
		rightChild.connect('size-allocate', self.RebuildTable)
		self.SetMainWidgets(leftChild, rightChild)

	def BuildTable(self, viewPort):
		pluginWindow = gtk.VBox()
		pluginWindow.set_border_width(10)
		viewPort.add(pluginWindow)

		self.TableCats = {}
		self.TableAttached = False
		self.LastCols = -1
		for category in sorted(self.Categories, self.CatSortCompare):
			pluginList = self.Categories[category]
			categoryBox = gtk.VBox()
			categoryHeader = gtk.HBox()
			categoryHeader.set_spacing(10)
			categoryLabel = MakeLabel('', -1)
			pluginWindow.pack_start(categoryBox, False, False)

			name = category or 'Uncategorized'
			categoryLabel.set_markup("<span color='#aaa' size='x-large' weight='800'>%s</span>" % name)
			categoryImg = self.MakeImage(category = name.lower().replace(" ", "_"))
			if categoryImg:
				categoryHeader.pack_start(categoryImg, False, False)
			categoryHeader.pack_start(categoryLabel, False, False)
			categoryBox.pack_start(categoryHeader, False, False)
			
			categoryTab = gtk.Table()
			categoryTab.set_border_width(10)
			self.TableCats[category] = (categoryTab, [], [])
			categoryBox.pack_start(categoryTab, False, False)
			
			for plugin in pluginList:
				pluginButton = gtk.Button()
				pluginButton.connect('clicked', self.SelectPlugin, plugin)
				pluginButton.connect('enter', self.SetInfo, self.PluginDescription, plugin.LongDesc)
				pluginButton.connect('leave', self.ResetInfo, self.PluginDescription)
				pluginButton.set_size_request(200, -1)
				pluginButton.set_relief(gtk.RELIEF_NONE)
				pluginButtonBox = gtk.HBox(False, 10)
				pluginButtonBox.set_border_width(10)
				pluginImage = self.PluginImages[plugin.Name]
				pluginLabel = MakeLabel(plugin.ShortDesc, 120)
				pluginButtonBox.pack_start(pluginImage, False, False)
				pluginButtonBox.pack_start(pluginLabel, True, True)
				pluginButton.add(pluginButtonBox)
				pluginBox = gtk.HBox()

				if plugin.Name !=  'core':
					pluginEnable = gtk.CheckButton()
					pluginEnable.set_active(plugin.Enabled)
					pluginEnable.connect("toggled", self.EnablePlugin, plugin)
					pluginBox.pack_start(pluginEnable, False, False)

				pluginBox.pack_start(pluginButton, True, True)
				pluginBox.set_size_request(220, -1)
				self.TableCats[category][1].append(pluginBox)
				self.TableCats[category][2].append(plugin)

	# targets:
	# 0 = plugin name and short description
	# 1 = plugin long description
	# 2 = category
	def FilterTable(self, widget, target=0):
		text = widget.get_text().lower()
		cols = self.LastCols
		foundPlugin = False

		if self.TableAttached:
			for categoryName, categoryContainer in self.TableCats.items():
				for pluginButton in categoryContainer[1]:
					if pluginButton.get_parent():
						categoryContainer[0].remove(pluginButton)

		for categoryName, categoryContainer in self.TableCats.items():
			col = 0
			row = 0
			empty = True
			for pluginButton in categoryContainer[1]:
				index = categoryContainer[1].index(pluginButton)
				shortDesc = categoryContainer[2][index].ShortDesc.lower()
				longDesc = categoryContainer[2][index].LongDesc.lower()
				name = categoryContainer[2][index].Name.lower()
				category = categoryName.lower()
				show = False

				if target == 0:
					show = name.find(text) != -1 \
					or shortDesc.find(text) != -1
				elif target == 1:
					show = name.find(text) != -1 \
					or shortDesc.find(text) != -1 \
					or longDesc.find(text) != -1
				elif target == 2:
					show = category.find(text) != -1

				if show:
					empty = False
					foundPlugin = True
					categoryContainer[0].attach(pluginButton, col, col+1, row, row+1, 0)
					col = col+1
					if col >=  cols:
						col = 0
						row = row+1
			if empty:
				categoryContainer[0].get_parent().set_no_show_all(True)
				categoryContainer[0].get_parent().hide()
			else:
				categoryContainer[0].get_parent().set_no_show_all(False)
				categoryContainer[0].attach(gtk.Label(), cols+5, cols+6, 0, 1, gtk.EXPAND)
	
		# Search in long description
		if not foundPlugin and target == 0:
			self.FilterTable(widget, 1)
			return
		# Search in category
		elif not foundPlugin and target == 1:
			self.FilterTable(widget, 2)
			return

		self.TableAttached = True
		self.MainWin.show_all()

	def RebuildTable(self, widget, request):
		cols = (request.width - 60) / 220
		if cols == self.LastCols:
			return
		
		self.LastCols = cols
		if self.TableAttached:
			for categoryName, categoryContainer in self.TableCats.items():
				for pluginButton in categoryContainer[1]:
					categoryContainer[0].remove(pluginButton)
		
		for categoryName, categoryContainer in self.TableCats.items():
			col = 0
			row = 0
			for pluginButton in categoryContainer[1]:
				categoryContainer[0].attach(pluginButton, col, col+1, row, row+1, 0)
				col = col+1
				if col >= cols:
					col = 0
					row = row+1
			categoryContainer[0].attach(gtk.Label(), cols+5, cols+6, 0, 1, gtk.EXPAND)
		self.TableAttached = True
		self.MainWin.show_all()
		self.RightPane.get_child().props.vadjustment.value = self.RightVadj

	def SetMainWidgets(self, leftWidget, rightWidget):
		pane = self.LeftPane.get_child()
		if pane:
			pane.destroy()
		pane = self.RightPane.get_child()
		if (pane):
			pane.destroy()
		self.LeftPane.add(leftWidget)
		self.RightPane.add(rightWidget)
		self.MainWin.show_all()

	def CatSortCompare(self, v1, v2):
		if v1 == v2:
			return cmp(v1, v2)
		if v1 == 'General':
			return cmp('', v2 or 'zzzzzzzz')
		if v2 == 'General':
			return cmp(v1 or 'zzzzzzz', '')
		return cmp(v1 or 'zzzzzzzz', v2 or 'zzzzzzzz')

	def MakeImage(self, plugin = 0, category = 0, size = 32):
		img = gtk.Image()
		if plugin != 0:
			iconpath = "%s/plugin-%s.svg"%(PixmapDir, plugin.Name)
			if not os.path.exists(iconpath):
				iconpath = "%s/plugin-unknown.svg"%PixmapDir
			try:
				pixbuf = gtk.gdk.pixbuf_new_from_file_at_size(iconpath, size, size)
				img.set_from_pixbuf(pixbuf)
			except:
				img.set_from_stock(gtk.STOCK_MISSING_IMAGE, gtk.ICON_SIZE_BUTTON)
		elif category != 0:
			try:
				pixbuf = gtk.gdk.pixbuf_new_from_file_at_size("%s/category-%s.svg"%(
					PixmapDir, category), size, size)
				img.set_from_pixbuf(pixbuf)
			except:
				img.set_from_stock(gtk.STOCK_MISSING_IMAGE, gtk.ICON_SIZE_BUTTON)
		return img

	def SelectPlugin(self, obj, select):
		self.RightVadj = self.RightPane.get_child().get_vadjustment().get_value()
		for name, value in self.PluginImages.items():
			widget = value.get_parent()
			if widget:
				widget.remove(value)
		pluginClass = PluginClass(select, self)
		self.SetMainWidgets(pluginClass.LeftWidget, pluginClass.RightWidget)
	
	def ShowProfileBackend(self, obj):
		self.RightVadj = self.RightPane.get_child().get_vadjustment().get_value()
		for name, value in self.PluginImages.items():
			widget = value.get_parent()
			if widget:
				widget.remove(value)
		profBackPage = ProfileBackendPage(self, self.Context)
		self.SetMainWidgets(profBackPage.LeftWidget, profBackPage.RightWidget)

	def SetInfo(self, widget, label, text):
		label.set_markup(text)
	
	def ResetInfo(self, widget, label):
		label.set_markup("")

	def Expand(self, widget, box):
		if box.get_no_show_all():
			box.set_no_show_all(False)
			self.LeftPane.show_all()
			buttonImg = widget.get_child().get_children()[1]
			buttonImg.set_from_stock(gtk.STOCK_GO_DOWN, gtk.ICON_SIZE_BUTTON)
		else:
			box.set_no_show_all(True)
			box.hide()
			self.LeftPane.show_all()
			buttonImg = widget.get_child().get_children()[1]
			buttonImg.set_from_stock(gtk.STOCK_GO_UP, gtk.ICON_SIZE_BUTTON)

	def UpdatePlugins(self):
		for category, container, plugins in self.TableCats.values():
				for i in range(len(plugins)):
					if plugins[i].Name != 'core':
						check = container[i].get_children()[0]
						self.BlockEnablePlugin += 1
						check.set_active(plugins[i].Enabled)
						self.BlockEnablePlugin -= 1
	
	def EnablePlugin(self, widget, plugin):
		if self.BlockEnablePlugin > 0:
			return 

		# attempt to resolve conflicts...
		conflicts = plugin.Enabled and plugin.DisableConflicts or plugin.EnableConflicts
		if HandlePluginConflicts(conflicts):
			plugin.Enabled = widget.get_active()
			self.UpdatePlugins()
		else:
			widget.set_active(plugin.Enabled)
		Write(plugin.Context)

	def ToggleCategory(self, widget, category):
		categoryContainer = self.TableCats[category]
		categoryY = categoryContainer[0].get_parent().get_allocation().y
		parentY = self.RightPane.get_child().get_allocation().y
		parentHeight = self.RightPane.get_child().get_allocation().height
		categoryBox = self.RightPane.get_child().get_child().get_child()
		boxHeight = categoryBox.get_allocation().height
		posY = categoryY - parentY
		neededHeight = posY + parentHeight
		if neededHeight > boxHeight:
			posY =  boxHeight - parentHeight
		self.RightPane.get_child().props.vadjustment.value = posY
	
	def ScreenChanged(self, widget):
		self.Context.Write()
		CurrentScreenNum = widget.get_active()
		self.Context.Read()

	def BackToMain(self, obj):
		self.ResetMainWidgets()
		
screens = getScreens()
CurrentScreenNum = gtk.gdk.display_get_default().get_default_screen().get_number()
context = ccs.Context(screens, len(screens))
mainWin = MainWinClass(context).MainWin
mainWin.show_all()
gtk.main()
