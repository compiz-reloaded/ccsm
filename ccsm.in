#!/usr/bin/env python
# -*- coding: UTF-8 -*-

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, 
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
# Authors: Quinn Storm (quinn@beryl-project.org)
#          Patrick Niklaus (marex@opencompositing.org)
# Copyright (C) 2007 Quinn Storm


import os
import compizconfig
try:
	import sexy
	has_sexy = True
except ImportError:
	print "Warning: No sexy-python package found."
	has_sexy = False
import pygtk
pygtk.require('2.0')
import gtk
import gtk.gdk
import cairo

#l10n stuff
import locale
import gettext

import gobject
import os
import re
gdk = gtk.gdk
ccs = compizconfig
from xml.sax.saxutils import escape as EscapeMarkup

DataDir = "@prefix@/share"
IconDir = DataDir+"/icons/hicolor/scalable"
PixmapDir = DataDir+"/ccsm/images"
CurrentScreenNum = 0
Tooltips = gtk.Tooltips()
VisibleSettings = []

locale.setlocale(locale.LC_ALL, "")
gettext.bindtextdomain("ccsm", DataDir + "/locale")
gettext.textdomain("ccsm")
_ = gettext.gettext

if gtk.pygtk_version < (2,10,0):
    print _("PyGtk 2.10.0 or later required")
    raise SystemExit

def Write(ctx):
	ctx.Write()

def UpdateVisibleSettings(context):
	changed = context.ProcessEvents()
	if changed:
		for settingWidget in VisibleSettings:
			settingWidget.Read()
		context.ClearChangedSettings()
	return True

def getScreens():
	screens = []
	display = gtk.gdk.display_get_default()
	nScreens = display.get_n_screens()
	for i in range(nScreens):
		screens.append(i)
	return screens

def CheckConflict(setting, con, typ):

	msg = _("The new value for the %s binding for the action <b>%s</b> "\
		  "in plugin <b>%s</b> conflicts with the action <b>%s</b> of the <b>%s</b> plugin.\n"\
		  "Do you wish to disable <b>%s</b> in the <b>%s</b> plugin?")
	 
	msg = msg % (typ, setting.ShortDesc, setting.Plugin.ShortDesc, con.ShortDesc, con.Plugin.ShortDesc, con.ShortDesc, con.Plugin.ShortDesc)
	
	dlg = gtk.MessageDialog(parent=mainWin, flags=gtk.DIALOG_MODAL, type=gtk.MESSAGE_WARNING)

	yesButton = gtk.Button(_("Disable %s") % con.ShortDesc)
	yesButton.set_image(gtk.image_new_from_stock(gtk.STOCK_YES, gtk.ICON_SIZE_BUTTON))
	dlg.add_action_widget(yesButton, gtk.RESPONSE_YES)

	noButton = gtk.Button(_("Don't set %s") % setting.ShortDesc)
	noButton.set_image(gtk.image_new_from_stock(gtk.STOCK_NO, gtk.ICON_SIZE_BUTTON))
	dlg.add_action_widget(noButton, gtk.RESPONSE_NO)

	ignoreButton = gtk.Button(_("Set %s anyway") % setting.ShortDesc)
	ignoreButton.set_image(gtk.image_new_from_stock(gtk.STOCK_STOP, gtk.ICON_SIZE_BUTTON))
	dlg.add_action_widget(ignoreButton, gtk.RESPONSE_REJECT)

	dlg.set_markup(msg)
	dlg.show_all()
	ret = dlg.run()
	dlg.destroy()

	return ret

def CheckActionConflicts(setting, key, button, bell, edges, edgeButton):
	keyCon = []
	buttonCon = []
	edgeCon = []
	
	# this might be a bit slow but anyway...
	for plugin in setting.Plugin.Context.Plugins.values():
		if plugin.Enabled:
			settings = sum((z.values() for z in [plugin.Screens[CurrentScreenNum]]+[plugin.Display]), [])
			for s in settings:
				if s.Type == 'Action' and s != setting:
					if s.Value[0] == key and key != '':
						keyCon.append(s)
					if s.Value[1] == button and button != 'None':
						buttonCon.append(s)
					if s.Value[3] == edges and edges != None and edges != []:
						edgeCon.append(s)

	if len(keyCon) and key and key.lower() != 'disabled' and key.lower() != 'none':
		for k in keyCon:
			ret = CheckConflict(setting, k, 'Key')
			if ret == gtk.RESPONSE_YES:
				value = k.Value
				k.Value = ['None', value[1], value[2], value[3], value[4]]
			if ret == gtk.RESPONSE_NO:
				return False
	
	if len(buttonCon) and button and button.lower() != 'disabled' and button.lower() != 'none':
		for b in buttonCon:
			ret = CheckConflict(setting, b, 'Button')
			if ret == gtk.RESPONSE_YES:
				value = b.Value
				b.Value = [value[0], 'None', value[2], value[3], value[4]]
			if ret == gtk.RESPONSE_NO:
				return False

	if len(edgeCon) and edges:
		for e in edgeCon:
			ret = CheckConflict(setting, e, 'Edge')
			if ret == gtk.RESPONSE_YES:
				value = e.Value
				e.Value = [value[0], value[1], value[2], [], value[4]]
			if ret == gtk.RESPONSE_NO:
				return False

	return True

# Not used for plugin dependencies (which are handled by ccs) but own feature checking e.g. image support
def CheckFeature(context, feature):
	for plugin in context.Plugins.values():
		if plugin.Features.__contains__(feature):
			if plugin.Enabled:
				return True
			else:
				msg = _("You are trying to use the feature <b>%s</b> which is provided by <b>%s</b>.\n"\
					  "This plugin is currently disabled.\n"\
					  "Do you wish to enable <b>%s</b> so the feature is available?")
				 
				msg = msg % (feature, plugin.ShortDesc, plugin.ShortDesc)
				
				dlg = gtk.MessageDialog(parent=mainWin, flags=gtk.DIALOG_MODAL, type=gtk.MESSAGE_WARNING)

				yesButton = gtk.Button(_("Enable %s") % plugin.ShortDesc)
				yesButton.set_image(gtk.image_new_from_stock(gtk.STOCK_YES, gtk.ICON_SIZE_BUTTON))
				dlg.add_action_widget(yesButton, gtk.RESPONSE_YES)

				noButton = gtk.Button(_("Don't enable %s") % plugin.ShortDesc)
				noButton.set_image(gtk.image_new_from_stock(gtk.STOCK_NO, gtk.ICON_SIZE_BUTTON))
				dlg.add_action_widget(noButton, gtk.RESPONSE_NO)

				dlg.set_markup(msg)
				dlg.show_all()
				ret = dlg.run()
				dlg.destroy()

				if ret == gtk.RESPONSE_YES:
					plugin.Enabled = True
					context.Write()
					return True
				if ret == gtk.RESPONSE_NO:
					return False
	
	return False

class PureVirtualError(Exception):
	pass

TDef = gtk.FILL | gtk.EXPAND
TXp = 4
TYp = 2

class SettingItem:
	def __init__(self, Setting):
		self.Custom = False
		self.Setting = Setting
		self.Blocked = 0
		self.MakeLabel()
		self.Reset = gtk.Button()
		Tooltips.set_tip(self.Reset,_("Reset setting to the default value"))
		self.Reset.set_image(gtk.image_new_from_stock(
			gtk.STOCK_CLEAR, gtk.ICON_SIZE_BUTTON))
		self.Reset.connect('clicked', self.DoReset)
		self._Init()
		VisibleSettings.append(self)

	def Attach(self, table, row):
		self.Reset.set_sensitive(not self.Setting.ReadOnly)
		self.Widget.set_sensitive(not self.Setting.ReadOnly)
		if self.Custom:
			table.attach(self.Widget, 0, 100, row, row+1, TDef, TDef, TXp, TYp)
		else:
			table.attach(self.Label, 0, 1, row, row+1, gtk.FILL, TDef, TXp, TYp)
			table.attach(self.Widget, 1, 99, row, row+1, TDef, TDef, TXp, TYp)
			table.attach(self.Reset, 99, 100, row, row+1, 0, TDef, TXp, TYp)

	def PureVirtual(self, str):
		raise PureVirtualError, str, self.Setting.Name

	def _Init(self):
		self.PureVirtual('_Init')
	
	def DoReset(self, foo):
		self.Setting.Reset()
		Write(self.Setting.Plugin.Context)
		self.Read()

	def MakeLabel(self):
		self.Label = gtk.EventBox()
		label = gtk.Label()
		if self.Setting.Integrated:
			label.set_markup("<span foreground=\"blue\">%s</span>" % self.Setting.ShortDesc)
		else:
			label.set_markup("<span>%s</span>" % self.Setting.ShortDesc)
		self.Label.add(label)
		Tooltips.set_tip(self.Label, self.Setting.LongDesc)
		label.props.xalign = 0
		label.props.wrap_mode = gtk.WRAP_WORD
		label.set_size_request(160, -1)
		label.set_line_wrap(True)

	def Block(self):
		self.Blocked = self.Blocked+1
	
	def UnBlock(self):
		self.Blocked = self.Blocked-1

	def Read(self):
		self.Block()
		self._Read()
		self.UnBlock()

	def _Read(self):
		self.PureVirtual('_Read')

	def Changed(self, *args, **kwargs):
		if self.Blocked <= 0:
			self._Changed()
			Write(self.Setting.Plugin.Context)

	def _Changed(self):
		self.PureVirtual('_Changed')

class StringMatchSetting(SettingItem):
	def _Init(self):
		self.Entry = gtk.Entry()
		Tooltips.set_tip(self.Entry, self.Setting.LongDesc)
		self.Entry.connect('changed', self.Changed)
		self.Widget = self.Entry

	def _Read(self):
		self.Entry.set_text(self.Setting.Value)

	def _Changed(self):
		self.Setting.Value = self.Entry.get_text()

class FileSetting:
	def __init__(self, Setting):
		self.Setting = Setting
		self.Open = gtk.Button()
		Tooltips.set_tip(self.Open, _("Browse for ") + self.Setting.LongDesc)
		self.Open.set_image(gtk.image_new_from_stock(
			gtk.STOCK_OPEN, gtk.ICON_SIZE_BUTTON))
		self.Open.connect('clicked', self.OpenFileChooser)
	
	def CreateFilter(self):
		filter = gtk.FileFilter()
		if len(self.Setting.Hints) > 1:
			if self.Setting.Hints[1] == 'image':
				filter.set_name(_("Images"))
				filter.add_pattern("*.png")
				filter.add_pattern("*.jpg")
				filter.add_pattern("*.jpeg")
				filter.add_pattern("*.svg")
			else:
				filter.add_pattern("*.*")
		else:
			filter.add_pattern("*")
			filter.set_name(_("File"))

		return filter

	def CheckFileType(self, filename):
		# we need the feature support in the compiz-repo
		#ext = filename.split(".")[-1]
		#if len(self.Setting.Hints) > 1:
		#	if self.Setting.Hints[1] == 'image':
		#		return CheckFeature(self.Setting.Plugin.Context, 'imageext:' + ext)
		
		return True
			
	def OpenFileChooser(self, widget, custom_value=None):
		value = self.Setting.Value
		if custom_value != None:
			value = custom_value
		b = (gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL, gtk.STOCK_OPEN, gtk.RESPONSE_OK)
		chooser = gtk.FileChooserDialog(title=_("Open file.."), parent=mainWin, buttons=b)
		
		if os.path.exists(value):
			chooser.set_filename(value)
		else:
			chooser.set_current_folder(os.environ.get("HOME"))
		chooser.set_filter(self.CreateFilter())
		ret = chooser.run()
		
		filename = chooser.get_filename()
		chooser.destroy()
		if ret == gtk.RESPONSE_OK:
			if self.CheckFileType(filename):
				self.SetFileName(filename)
	
	def SetFileName(self, text):
		self.PureVirtual('SetFileName')

class FileStringSetting(StringMatchSetting, FileSetting):
	def __init__(self, Setting):
		StringMatchSetting.__init__(self, Setting)
		FileSetting.__init__(self, Setting)
		self.Widget = gtk.HBox()
		self.Widget.set_spacing(5)
		self.Widget.pack_start(self.Entry, True, True)
		self.Widget.pack_start(self.Open, False, False)

	def SetFileName(self, filename):
		self.Entry.set_text(filename)

def EnumSettingSortCompare(v1, v2):
	return cmp(v1[1], v2[1])

class EnumSetting(SettingItem):
	def _Init(self):
		self.Widget = gtk.EventBox()
		Tooltips.set_tip(self.Widget, self.Setting.LongDesc)
		self.Combo = gtk.combo_box_new_text()
		self.Widget.add(self.Combo)
		sortedItems = sorted(self.Setting.Info[2].items(), EnumSettingSortCompare)
		for name, value in sortedItems:
			self.Combo.append_text(name)
		self.Combo.connect('changed', self.Changed)

	def _Read(self):
		self.Combo.set_active(self.Setting.Value)

	def _Changed(self):
		active = self.Combo.get_active_text()
		self.Setting.Value = self.Setting.Info[2][active]

class BoolSetting(SettingItem):
	def _Init(self):
		self.Custom = True
		self.Widget = gtk.HBox()
		self.CheckButton = gtk.CheckButton(self.Setting.ShortDesc)
		label = self.CheckButton.get_child()
		if self.Setting.Integrated:
			label.set_markup("<span foreground=\"blue\">%s</span>" % self.Setting.ShortDesc)
		Tooltips.set_tip(self.CheckButton, self.Setting.LongDesc)
		self.Widget.pack_start(self.CheckButton, True, True)
		self.Widget.pack_start(self.Reset, False, False)
		self.CheckButton.connect('toggled', self.Changed)

	def _Read(self):
		self.CheckButton.set_active(self.Setting.Value)

	def _Changed(self):
		self.Setting.Value = self.CheckButton.get_active()

class IntFloatSetting(SettingItem):
	def _Init(self):
		inc = 1
		if self.Setting.Type == 'Int':
			inc = 1
		else:
			inc = self.Setting.Info[2]

		self.Adj = gtk.Adjustment(self.Setting.Value, self.Setting.Info[0], self.Setting.Info[1], inc, inc*10)
		self.Spin = gtk.SpinButton(self.Adj)
		Tooltips.set_tip(self.Spin, self.Setting.LongDesc)
		
		if self.Setting.Type == 'Float':
			self.Spin.set_digits(4)
		
		self.Scale = gtk.HScale(self.Adj)
		Tooltips.set_tip(self.Scale, self.Setting.LongDesc)
		self.Scale.props.draw_value = False
		self.Adj.connect('value-changed', self.Changed)

	def Attach(self, Table, row):
		self.Reset.set_sensitive(not self.Setting.ReadOnly)
		self.Scale.set_sensitive(not self.Setting.ReadOnly)
		self.Spin.set_sensitive(not self.Setting.ReadOnly)
		Table.attach(self.Label, 0, 1, row, row+1, gtk.FILL, TDef, TXp, TYp)
		Table.attach(self.Scale, 1, 2, row, row+1, TDef, TDef, TXp, TYp)
		Table.attach(self.Spin, 2, 3, row, row+1, gtk.FILL, TDef, TXp, TYp)
		Table.attach(self.Reset, 99, 100, row, row+1, 0, TDef, TXp, TYp)

	def _Read(self):
		self.Adj.set_value(self.Setting.Value)

	def _Changed(self):
		self.Setting.Value = self.Adj.get_value()

class ColorSetting(SettingItem):
	def _Init(self):
		self.Widget = gtk.ColorButton()
		Tooltips.set_tip(self.Widget, self.Setting.LongDesc)
		self.Widget.set_use_alpha(True)
		self.Widget.connect('color-set', self.Changed)

	def _Read(self):
		col = gdk.Color()
		col.red = self.Setting.Value[0]
		col.green = self.Setting.Value[1]
		col.blue = self.Setting.Value[2]
		self.Widget.set_color(col)
		self.Widget.set_alpha(self.Setting.Value[3])

	def _Changed(self):
		col = self.Widget.get_color()
		alpha = self.Widget.get_alpha()
		self.Setting.Value = [col.red, col.green, col.blue, alpha]

class MultiListSetting(SettingItem):
	def _Init(self):
		self.Widget = gtk.VBox()
		self.Custom = True
		self.Settings = self.Setting # self.Setting is a list in this case
		
		types, cols = self.ListInfo()
		self.Types = types
		self.Store = gtk.ListStore(*types)
		self.View = gtk.TreeView(self.Store)
		Tooltips.set_tip(self.View, _("Multi-list settings"))
		self.View.set_headers_visible(True)
		for col in cols:
			self.View.insert_column_with_attributes(-1, col[0], col[1], **col[2])
		self.Store.connect('row-deleted', self.Changed)
		self.Store.connect('rows-reordered', self.Changed)
		self.Select = self.View.get_selection()
		self.Select.set_mode(gtk.SELECTION_MULTIPLE)

		self.Widget.set_border_width(5)
		self.Widget.set_spacing(5)
		self.Widget.set_size_request(-1, 150)
		self.Scroll = gtk.ScrolledWindow()
		self.Scroll.props.hscrollbar_policy = gtk.POLICY_NEVER
		self.Scroll.props.hscrollbar_policy = gtk.POLICY_AUTOMATIC
		self.Scroll.add(self.View)
		self.Widget.pack_start(self.Scroll, True, True)
		
		buttonBox = gtk.HBox(False)
		buttonBox.set_spacing(5)
		self.Widget.pack_start(buttonBox, False, False)
		buttonTypes = ((gtk.STOCK_ADD, self.Add),
				 (gtk.STOCK_DELETE, self.Delete), 
				 (gtk.STOCK_EDIT, self.Edit),
				 (gtk.STOCK_GO_UP, self.MoveUp), 
				 (gtk.STOCK_GO_DOWN, self.MoveDown),)
		for type in buttonTypes:
			b = gtk.Button(type[0])
			b.set_use_stock(True)
			buttonBox.pack_start(b, False, False)
			b.connect('clicked', type[1])
		buttonBox.pack_end(self.Reset, False, False)

	def ColChanged(self, *args, **kwargs):
		if self.Blocked <= 0:
			self._ColChanged(*args, **kwargs)
			Write(self.Settings[0].Plugin.Context)

	def Changed(self, *args, **kwargs):
		if self.Blocked <= 0:
			self._Changed()
			Write(self.Settings[0].Plugin.Context)

	def DoReset(self, foo):
		for setting in self.Settings:
			setting.Reset()
		Write(self.Setting[0].Plugin.Context)
		self.Read()

	def MakeLabel(self):
		pass
	
	def Add(self, b):
		values = self._Edit()
		if values is not None:
			self.Block()
			iter = self.Store.append()
			self.UnBlock()
			col = 0
			for value in values:
				self.SetIterValue(iter, col, value)
				col += 1
			self.Changed()

	def Delete(self, b):
		selectedRows = self.Select.get_selected_rows()[1]
		for path in selectedRows:
			iter = self.Store.get_iter(path)
			self.Store.remove(iter)

	def Edit(self, b):
		selectedRows = self.Select.get_selected_rows()[1]
		if len(selectedRows) == 1:
			iter = self.Store.get_iter(selectedRows[0])
			values = []
			for col in range(len(self.Settings)):
				value = self.Store.get(iter, col)[0]
				values.append(value)
			values = self._Edit(values)
			if values != None:
				col = 0
				for value in values:
					self.SetIterValue(iter, col, value)
					col += 1
				self.Changed()

	def MoveUp(self, b):
		selectedRows = self.Select.get_selected_rows()[1]
		if len(selectedRows) == 1:
			iter = self.Store.get_iter(selectedRows[0])
			prev = self.Store.get_iter_first()
			if not self.Store.get_path(prev) == self.Store.get_path(iter):
				while prev is not None and not self.Store.get_path(self.Store.iter_next(prev)) == self.Store.get_path(iter):
					prev = self.Store.iter_next(prev)
				self.Store.swap(iter, prev)

	def MoveDown(self, b):
		selectedRows = self.Select.get_selected_rows()[1]
		if len(selectedRows) == 1:
			iter = self.Store.get_iter(selectedRows[0])
			next = self.Store.iter_next(iter)
			if next is not None:
				self.Store.swap(iter, next)

	def ListInfo(self):
		types = []
		cols = []
		col = 0
		for setting in self.Settings:
			if setting.Info[0] == "String" or setting.Info[0] == "Match":
				types.append(gobject.TYPE_STRING)
			elif setting.Info[0] == "Int":
				types.append(gobject.TYPE_INT)
			elif setting.Info[0] == "Float":
				types.append(gobject.TYPE_FLOAT)
			
			renderer = gtk.CellRendererText()
			renderer.connect("edited", self.ColChanged, col)
			cols.append((setting.ShortDesc, renderer, {'text':col, 'editable':True}))
			col += 1

		return types, cols

	def _Read(self):
		self.Store.clear()
		iters = []
		for values in self.Settings[0].Value:
			iters.append(self.Store.append())

		row = 0
		for iter in iters:
			for j in range(len(self.Settings)):
				setting = self.Settings[j]
				value = setting.Value[row]
				self.Store.set(iter, j, value)
			row += 1

	def _Edit(self, values=None):
		dlg = gtk.Dialog(_("Edit"), mainWin)
		dlg.add_button(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL)
		dlg.add_button(gtk.STOCK_OK, gtk.RESPONSE_OK).grab_default()
		dlg.set_default_response(gtk.RESPONSE_OK)
		table = gtk.Table()
		dlg.vbox.pack_start(table)

		row = 0
		widgets = []
		for setting in self.Settings:
			if self.Types[row] == gobject.TYPE_STRING:
				ebox = gtk.EventBox()
				label = gtk.Label(setting.ShortDesc)
				ebox.add(label)
				Tooltips.set_tip(ebox, setting.LongDesc)
				entry = gtk.Entry()
				Tooltips.set_tip(entry, setting.LongDesc)
				if values != None:
					entry.set_text(values[row])
				table.attach(ebox, 0, 1, row, row+1, xpadding=5, xoptions=gtk.FILL)
				table.attach(entry, 2, 3, row, row+1, xpadding=5)
				widgets.append(entry)
			elif self.Types[row] == gobject.TYPE_INT or self.Types[row] == gobject.TYPE_FLOAT:
				ebox = gtk.EventBox()
				label = gtk.Label(setting.ShortDesc)
				ebox.add(label)
				Tooltips.set_tip(ebox, setting.LongDesc)
				inc = 0
				if setting.Info[0] == 'Int':
					inc = 1
				else:
					inc = setting.Info[1][2]
				value = 0
				if values != None:
					value = values[row]
				adjustment = gtk.Adjustment(value, setting.Info[1][0], setting.Info[1][1], inc, inc*10)
				spin = gtk.SpinButton(adjustment)
				Tooltips.set_tip(spin, setting.LongDesc)
				if setting.Info[0] == 'Float':
					spin.set_digits(4)
				scale = gtk.HScale(adjustment)
				Tooltips.set_tip(scale, setting.LongDesc)
				scale.props.draw_value = False
				table.attach(ebox, 0, 1, row, row+1, xpadding=5, xoptions=gtk.FILL)
				table.attach(scale, 2, 3, row, row+1, xpadding=5)
				table.attach(spin, 3, 4, row, row+1, xpadding=5, xoptions=gtk.FILL)
				widgets.append(adjustment)
			row += 1

		dlg.vbox.show_all()
		ret = dlg.run()
		dlg.destroy()

		if ret == gtk.RESPONSE_OK:
			values = []
			row = 0
			for type in self.Types:
				if type == gobject.TYPE_STRING:
					value = widgets[row].get_text()
					values.append(value)
				elif type == gobject.TYPE_INT:
					value = int(widgets[row].get_value())
					values.append(value)
				elif type == gobject.TYPE_FLOAT:
					value = widgets[row].get_value()
					values.append(value)
				row += 1
			return values

		return None

	def SetIterValue(self, iter, col, value):
		if self.Types[col] == gobject.TYPE_STRING:
			self.Store.set(iter, col, value)
		elif self.Types[col] == gobject.TYPE_INT:
			self.Store.set(iter, col, int(value))
		elif self.Types[col] == gobject.TYPE_FLOAT:
			self.Store.set(iter, col, float(value))

	def _ColChanged(self, obj, path, value, col):
		iter = self.Store.get_iter_from_string(path)
		self.SetIterValue(iter, col, value)
		self._Changed()

	def _Changed(self):
		col = 0
		for setting in self.Settings:
			iter = self.Store.get_iter_first()
			values = []
			while iter:
				value = self.Store.get(iter, col)[0]
				if value != "":
					values.append(value)
				iter = self.Store.iter_next(iter)
			setting.Value = values
			col += 1

	def Attach(self, table, row):
		table.attach(self.Widget, 0, 100, row, row+1, xpadding=5)

class ListSetting(SettingItem):
	def _Init(self):
		self.Widget = gtk.Frame(self.Setting.ShortDesc)
		label = self.Widget.get_label_widget()
		if self.Setting.Integrated:
			label.set_markup("<span foreground=\"blue\">%s</span>" % self.Setting.ShortDesc)
		self.Custom = True
		
		info = self._ListInfo()
		self.Store = gtk.ListStore(*info[0])
		self.View = gtk.TreeView(self.Store)
		Tooltips.set_tip(self.View, self.Setting.LongDesc)
		if len(info[0]) == 1:
			self.View.set_headers_visible(False)
		for i in info[1]:
			self.View.insert_column_with_attributes(-1, i[1], i[0], **i[2])
		self.Store.connect('row-changed', self.Changed)
		self.Store.connect('row-deleted', self.Changed)
		self.Store.connect('row-inserted', self.Changed)
		self.Store.connect('rows-reordered', self.Changed)
		self.Select = self.View.get_selection()
		self.Select.set_mode(gtk.SELECTION_MULTIPLE)

		box = gtk.VBox()
		box.set_border_width(5)
		box.set_spacing(5)
		self.Widget.add(box)
		self.Scroll = gtk.ScrolledWindow()
		self.Scroll.props.hscrollbar_policy = gtk.POLICY_NEVER
		self.Scroll.props.hscrollbar_policy = gtk.POLICY_AUTOMATIC
		self.Scroll.add(self.View)
		box.pack_start(self.Scroll, True, True)
		
		buttonBox = gtk.HBox(False)
		buttonBox.set_spacing(5)
		box.pack_start(buttonBox, False, False)
		buttonTypes = ((gtk.STOCK_ADD, self.Add),
				 (gtk.STOCK_DELETE, self.Delete), 
				 (gtk.STOCK_EDIT, self.Edit),
				 (gtk.STOCK_GO_UP, self.MoveUp), 
				 (gtk.STOCK_GO_DOWN, self.MoveDown),)
		for type in buttonTypes:
			b = gtk.Button(type[0])
			b.set_use_stock(True)
			buttonBox.pack_start(b, False, False)
			b.connect('clicked', type[1])
		buttonBox.pack_end(self.Reset, False, False)

	def Add(self, b):
		value = self._Edit()
		if value is not None:
			self.Block()
			Iter = self.Store.append()
			self.UnBlock()
			self._ListSet(Iter, value)

	def Delete(self, b):
		selectedRows = self.Select.get_selected_rows()[1]
		for path in selectedRows:
			iter = self.Store.get_iter(path)
			self.Store.remove(iter)

	def Edit(self, b):
		selectedRows = self.Select.get_selected_rows()[1]
		if len(selectedRows) == 1:
			iter = self.Store.get_iter(selectedRows[0])
			value = self._Edit(self._ListGet(iter))
			if value is not None:
				self._ListSet(iter, value)

	def MoveUp(self, b):
		selectedRows = self.Select.get_selected_rows()[1]
		if len(selectedRows) == 1:
			iter = self.Store.get_iter(selectedRows[0])
			prev = self.Store.get_iter_first()
			if not self.Store.get_path(prev) == self.Store.get_path(iter):
				while prev is not None and not self.Store.get_path(self.Store.iter_next(prev)) == self.Store.get_path(iter):
					prev = self.Store.iter_next(prev)
				self.Store.swap(iter, prev)

	def MoveDown(self, b):
		selectedRows = self.Select.get_selected_rows()[1]
		if len(selectedRows) == 1:
			iter = self.Store.get_iter(selectedRows[0])
			next = self.Store.iter_next(iter)
			if next is not None:
				self.Store.swap(iter, next)

	def _ListInfo(self):
		self.PureVirtual('_ListInfo')

	def _Read(self):
		self.Store.clear()
		for value in self.Setting.Value:
			iter = self.Store.append()
			self._ListSet(iter, value)

	def _ListSet(self, iter, value):
		self.PureVirtual('_ListRead')

	def _ListGet(self, iter):
		self.PureVirtual('_ListGet')

	def _Edit(self, d, value = None):
		self.PureVirtual('_Edit')

	def _Changed(self):
		values = []
		iter = self.Store.get_iter_first()
		while iter:
			value = self._ListGet(iter)
			if value != "":
				values.append(value)
			iter = self.Store.iter_next(iter)
		self.Setting.Value = values

	def Attach(self, table, row):
		self.Widget.set_sensitive(not self.Setting.ReadOnly)
		self.Reset.set_sensitive(not self.Setting.ReadOnly)
		table.attach(self.Widget, 0, 100, row, row+1, xpadding=5)

class StringMatchListSetting(ListSetting):
	def _ListInfo(self):
		return (gobject.TYPE_STRING, ), [(gtk.CellRendererText(), _("Value (%s)") % self.Setting.Info[0], {'text':0})]

	def _ListSet(self, iter, value):
		self.Store.set(iter, 0, value)

	def _ListGet(self, iter):
		return self.Store.get(iter, 0)[0]

	def _Edit(self, value=""):
		dlg = gtk.Dialog(_("Edit %s") % self.Setting.ShortDesc, mainWin)
		dlg.add_button(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL)
		dlg.add_button(gtk.STOCK_OK, gtk.RESPONSE_OK).grab_default()
		dlg.set_default_response(gtk.RESPONSE_OK)
		
		ebox = gtk.EventBox()
		label = gtk.Label(_("Value (%s) for %s:") % (self.Setting.Info[0], self.Setting.ShortDesc))
		ebox.add(label)
		
		Tooltips.set_tip(ebox, self.Setting.LongDesc)
		dlg.vbox.pack_start(ebox)
		
		entry = gtk.Entry()
		Tooltips.set_tip(entry, self.Setting.LongDesc)
		entry.props.activates_default = True
		entry.set_text(value)
		dlg.vbox.pack_start(entry)
		
		dlg.vbox.show_all()
		ret = dlg.run()
		dlg.destroy()

		if ret == gtk.RESPONSE_OK:
			return entry.get_text()
		return None

class FileListSetting(StringMatchListSetting, FileSetting):
	def __init__(self, Setting):
		StringMatchListSetting.__init__(self, Setting)
		FileSetting.__init__(self, Setting)
	
	def _Edit(self, value=""):
		dlg = gtk.Dialog(_("Edit %s") % self.Setting.ShortDesc, mainWin)
		dlg.add_button(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL)
		dlg.add_button(gtk.STOCK_OK, gtk.RESPONSE_OK).grab_default()
		dlg.set_default_response(gtk.RESPONSE_OK)
		
		ebox = gtk.EventBox()
		label = gtk.Label(_("Value (%s) for %s:") % (self.Setting.Info[0], self.Setting.ShortDesc))
		ebox.add(label)
		
		Tooltips.set_tip(ebox, self.Setting.LongDesc)
		dlg.vbox.pack_start(ebox)

		hbox = gtk.HBox()
		hbox.set_spacing(5)
		
		entry = gtk.Entry()
		Tooltips.set_tip(entry, self.Setting.LongDesc)
		entry.props.activates_default = True
		entry.set_text(value)
		hbox.pack_start(entry)

		self.Entry = entry

		open = gtk.Button()
		open.set_image(gtk.image_new_from_stock(gtk.STOCK_OPEN, gtk.ICON_SIZE_BUTTON))
		open.connect('clicked', self.OpenFileChooser, value)
		hbox.pack_start(open, False, False)

		dlg.vbox.pack_start(hbox)
		
		dlg.vbox.show_all()
		ret = dlg.run()
		dlg.destroy()

		self.Entry = None

		if ret == gtk.RESPONSE_OK:
			return entry.get_text()
		return None

	def SetFileName(self, filename):
		if self.Entry != None:
			self.Entry.set_text(filename)

class IntDescListSetting(SettingItem):
	def _Init(self):
		self.Widget = gtk.Frame(self.Setting.ShortDesc)
		self.Table = gtk.Table()
		self.Custom = True
		
		row = 0
		col = 0
		self.Checks = []
		sortedItems = sorted(self.Setting.Info[1][2].items(), EnumSettingSortCompare)
		self.minVal = sortedItems[0][1]
		for key, value in sortedItems:
			box = gtk.CheckButton(key)
			Tooltips.set_tip(box, self.Setting.LongDesc)
			self.Checks.append((key, box))
			self.Table.attach(box, col, col+1, row, row+1, TDef, TDef, TXp, TYp)
			box.connect('toggled', self.Changed)
			col = col+1
			if (col >=  3):
				col = 0
				row = row+1
		
		self.HBox = gtk.HBox()
		self.VBox = gtk.VBox()
		self.HBox.pack_start(self.VBox, False, False)
		self.HBox.pack_start(self.Table, True, True)
		self.VBox.pack_start(self.Reset, False, False)
		self.Widget.add(self.HBox)

	def _Read(self):
		for key, box in self.Checks:
			box.set_active(False)
		for setVal in self.Setting.Value:
			self.Checks[setVal-self.minVal][1].set_active(True)

	def _Changed(self):
		values = []
		for key, box in self.Checks:
			if box.get_active():
				values.append(self.Setting.Info[1][2][key])
		self.Setting.Value = values
	
	def Attach(self, table, row):
		self.Widget.set_sensitive(not self.Setting.ReadOnly)
		self.Reset.set_sensitive(not self.Setting.ReadOnly)
		table.attach(self.Widget, 0, 100, row, row+1, xpadding = 5)

class IntFloatListSetting(ListSetting):
	def _ListInfo(self):
		return (gobject.TYPE_STRING, ), [(gtk.CellRendererText(), 
			_("Value (%s)") % self.Setting.Info[0], {'text':0})]

	def _ListSet(self, Iter, v):
		self.Store.set(Iter, 0, str(v))

	def _ListGet(self, Iter):
		return eval(self.Store.get(Iter, 0)[0])

	def _Edit(self, value = None):
		dlg = gtk.Dialog(_("Edit %s") % self.Setting.ShortDesc, mainWin)
		dlg.add_button(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL)
		dlg.add_button(gtk.STOCK_OK, gtk.RESPONSE_OK).grab_default()
		dlg.set_default_response(gtk.RESPONSE_OK)
		label = gtk.Label(_("Value (%s) for %s:") % (self.Setting.Info[0], self.Setting.ShortDesc))
		ebox = gtk.EventBox()
		ebox.add(label)
		Tooltips.set_tip(ebox, self.Setting.LongDesc)
		dlg.vbox.pack_start(ebox)
		box = gtk.HBox()
		dlg.vbox.pack_start(box)
		
		val = self.Setting.Info[1][0]
		if value is not None:
			val = value
		
		if self.Setting.Info[0] == 'Int':
			inc = 1
		else:
			inc = self.Setting.Info[1][2]
		
		adj = gtk.Adjustment(val, 
				self.Setting.Info[1][0], self.Setting.Info[1][1], 
				inc, inc*10)
		spin = gtk.SpinButton(adj)
		Tooltips.set_tip(spin, setting.LongDesc)
		if self.Setting.Info[0] == 'Float':
			spin.set_digits(4)
		scale = gtk.HScale(adj)
		Tooltips.set_tip(scale, setting.LongDesc)
		scale.props.draw_value = False
		
		box.pack_start(scale, True, True)
		box.pack_start(spin, False, False)
		
		dlg.vbox.show_all()
		ret = dlg.run()
		dlg.destroy()

		if ret == gtk.RESPONSE_OK:
			return adj.get_value()
		return None

def MakeSetting(setting):
	if setting.Type == 'String' or setting.Type == 'Match':
		if len(setting.Hints) > 0 and setting.Hints.__contains__('file'):
			return FileStringSetting(setting)
		else:
			return StringMatchSetting(setting)
	elif setting.Type == 'Bool':
		return BoolSetting(setting)
	elif setting.Type == 'Int' and len(setting.Info[2].keys()) > 0:
		return EnumSetting(setting)
	elif setting.Type == 'Float' or setting.Type == 'Int':
		return IntFloatSetting(setting)
	elif setting.Type == 'Color':
		return ColorSetting(setting)
	elif setting.Type == 'List':
		if setting.Info[0] == 'String' or setting.Info[0] == 'Match':
			if len(setting.Hints) > 0 and setting.Hints.__contains__('file'):
				return FileListSetting(setting)
			else:
				return StringMatchListSetting(setting)
		elif setting.Info[0] == 'Int':
			if len(setting.Info[1][2]) > 0:
				return IntDescListSetting(setting)
			else:
				return IntFloatListSetting(setting)
		elif setting.Info[0] == 'Float':
			return IntFloatListSetting(setting)
		else:
			raise TypeError, _("Unhandled list type %s for %s")%(setting.Info[0], setting.Name)
	return None


def SettingSortCompare(v1, v2):
	return cmp(v1.Plugin.Ranking[v1.Name], v2.Plugin.Ranking[v2.Name])

# singleRun is used to combine the run stages, in this case run is a list
# containing the run levels which should be used to filter the settings
def FilterSettings(settings, filter, run=0, noActions=False, singleRun=False):
	if filter == None:
		return settings

	filteredSettings = []

	for setting in settings:
		if noActions and setting.Type == 'Action':
			continue
		if setting.Name == '____plugin_enabled':
			continue
		# First run, only search in shortDesc and name
		if run == 0 or (singleRun and run.count(0) != 0):
			shortDesc = setting.ShortDesc.lower()
			name = setting.Name.lower()
			if shortDesc.find(filter) != -1:
				filteredSettings.append(setting)
				continue
			elif name.find(filter) != -1:
				filteredSettings.append(setting)
				continue
		# Then in longDesc
		if run == 1 or (singleRun and run.count(1) != 0):
			longDesc = setting.LongDesc.lower()
			if longDesc.find(filter) != -1:
				filteredSettings.append(setting)
				continue
		# Finally search in the option value
		if run == 2 or (singleRun and run.count(2) != 0):
			value = ""
			# make sure enum settings work too
			if setting.Type == 'Int' and len(setting.Info[2].keys()) > 0:
					value = sorted(setting.Info[2].items(), EnumSettingSortCompare)[setting.Value][0]
					value = value.lower()
			# also make sure intDesc settings work right
			elif setting.Type == 'List' and setting.Info[0] == 'Int' and len(setting.Info[1][2]) > 0:
				for int in setting.Value:
					for item in setting.Info[1][2].items():
						if item[1] == int:
							value += item[0]
				value = value.lower()
			else:
				value = str(setting.Value).lower()
			if value.find(filter) != -1:
				filteredSettings.append(setting)

	# Nothing was found, search also in the longDesc/value
	if len(filteredSettings) == 0 and run < 2 and not singleRun:
		return FilterSettings(settings, filter, run+1, noActions, False)

	return filteredSettings

def HasOnlyType(settings, type):
	empty = True
	for setting in settings:
			if not setting.Name == '____plugin_enabled':
				empty = False
				if setting.Type != type:
					return False
	return not empty

class SubGroupArea:
	def __init__(self, name, subGroup, filter=None):
		self.MySettings = []
		#settings = sum((v.values() for v in [subGroup.Display]+[subGroup.Screens[CurrentScreenNum]]), [])
		settings = FilterSettings(sorted(sum((v.values() for v in [subGroup.Display]+[subGroup.Screens[CurrentScreenNum]]), []), SettingSortCompare), filter, noActions=True)
		if name == '':
			self.Widget = gtk.Table()
			self.Child = self.Widget
		else:
			self.Widget = gtk.Frame()
			self.Expander = gtk.Expander(name)
			self.Widget.add(self.Expander)
			self.Expander.set_expanded(False)
			self.Child = gtk.Table()
			self.Expander.add(self.Child)

			# create a special widget for list subGroups
			if HasOnlyType(settings, 'List'):
				multiList = MultiListSetting(settings)
				multiList.Read()
				multiList.Attach(self.Child, 0)
				self.Empty = False
				self.Expander.set_expanded(True)

				return # exit earlier to avoid unneeded logic's
		
		self.Empty = True
		row = 0
		for setting in settings:
			if not setting.Name == '____plugin_enabled':
				set = MakeSetting(setting)
				if set is not None:
					set.Read()
					set.Attach(self.Child, row)
					self.MySettings = self.MySettings + [set]
					row = row+1
					self.Empty = False

		if name != '' and row < 4: # ahi hay magic numbers!
			self.Expander.set_expanded(True)

class Page(object):
	def __init__(self, name):
		self.Widget = gtk.VBox()
		self.SetContainer = gtk.VBox()
		
		scroll = gtk.ScrolledWindow()
		scroll.props.hscrollbar_policy = gtk.POLICY_NEVER
		scroll.props.vscrollbar_policy = gtk.POLICY_AUTOMATIC
		
		view = gtk.Viewport()
		view.set_border_width(5)
		view.set_shadow_type(gtk.SHADOW_NONE)
		
		scroll.add(view)
		view.add(self.SetContainer)
		self.Widget.pack_start(scroll, True, True)
		
		self.Empty = True


class GroupPage(Page):
	def __init__(self, name, group, filter=None):
		super(GroupPage, self).__init__(name)

		self.subGroupAreas = []

		if (group.has_key('')):
			sga = SubGroupArea('', group[''], filter)
			if not sga.Empty:
				self.SetContainer.pack_start(sga.Widget, False, False)
				self.Empty = False
				self.subGroupAreas = self.subGroupAreas + [sga]

		subGroupsSorted = sorted(group.keys(), cmp)
		for subGroup in subGroupsSorted:
			if not subGroup == '':
				sga = SubGroupArea(subGroup, group[subGroup], filter)
				if not sga.Empty:
					self.SetContainer.pack_start(sga.Widget, False, False)
					self.Empty = False
					self.subGroupAreas = self.subGroupAreas + [sga]

def HandlePluginConflicts(plugin, conflicts):
	if len(conflicts) == 0:
		return True

	dlg = gtk.MessageDialog(parent = mainWin, flags = gtk.DIALOG_MODAL, type = gtk.MESSAGE_WARNING)
	okButton = gtk.Button()
	okButton.set_image(gtk.image_new_from_stock(gtk.STOCK_OK, gtk.ICON_SIZE_BUTTON))
	dlg.add_action_widget(okButton, gtk.RESPONSE_OK)

	cancelButton = gtk.Button()
	cancelButton.set_image(gtk.image_new_from_stock(gtk.STOCK_CANCEL, gtk.ICON_SIZE_BUTTON))
	dlg.add_action_widget(cancelButton, gtk.RESPONSE_CANCEL)

	for conflict in conflicts:
		if conflict[0] == 'ConflictFeature':
			# see if we can deactivate the plugin
			# mentioned in c[2]
			msg = _("Plugin <b>%s</b> provides feature <b>%s</b> which is also "\
				"provided by <b>%s</b>")
			msg = msg % (conflict[2][0].ShortDesc, conflict[1], plugin.ShortDesc)

			okButton.set_label(_("Disable %s") % conflict[2][0].ShortDesc)
			cancelButton.set_label(_("Don't enable %s") % plugin.ShortDesc)
			
			dlg.set_markup(msg)
			dlg.show_all()
			ret = dlg.run()
			dlg.destroy()

			if ret == gtk.RESPONSE_OK:
				disableConflicts = conflict[2][0].DisableConflicts
				if HandlePluginConflicts(conflict[2][0], disableConflicts):
					conflict[2][0].Enabled = False
				else:
					return False
			else:
				return False

		elif conflict[0] == 'ConflictPlugin':
			# see if we can deactivate the plugin
			# mentioned in c[2]
			msg = _("Plugin <b>%s</b> conflicts with <b>%s</b>.")
			msg = msg % (conflict[2][0].ShortDesc, plugin.ShortDesc)

			okButton.set_label(_("Disable %s") % conflict[2][0].ShortDesc)
			cancelButton.set_label(_("Don't enable %s") % plugin.ShortDesc)
			
			dlg.set_markup(msg)
			dlg.show_all()
			ret = dlg.run()
			dlg.destroy()
			if ret == gtk.RESPONSE_OK:
				disableConflicts = conflict[2][0].DisableConflicts
				if HandlePluginConflicts(conflict[2][0], disableConflicts):
					conflict[2][0].Enabled = False
				else:
					return False
			else:
				return False
		
		elif conflict[0] == 'RequiresFeature':
			# we need to activate one of c[2]
			pluginList = ', '.join("\"%s\"" % plugin.ShortDesc for plugin in conflict[2])
			msg = _("<b>%s</b> requires feature <b>%s</b> which is provided by the following plugins:\n%s")
			msg = msg % (plugin.ShortDesc, conflict[1], pluginList)

			okButton.set_label(_("Enable these plugins"))
			cancelButton.set_label(_("Don't enable %s") % plugin.ShortDesc)
			
			dlg.set_markup(msg)
			cmb = gtk.combo_box_new_text()
			dlg.vbox.pack_start(cmb, False, False)
			for plugin in conflict[2]:
				cmb.append_text(plugin.ShortDesc)
			cmb.set_active(0)
			dlg.show_all()
			ret = dlg.run()
			retVal = cmb.get_active_text()
			dlg.destroy()
			
			if ret == gtk.RESPONSE_OK:
				for plg in conflict[2]:
					if plg.ShortDesc == retVal:
						enableConflicts = plg.EnableConflicts
						if HandlePluginConflicts(plg, enableConflicts):
							plg.Enabled = True
						else:
							return False
						break
			else:
				return False

		elif conflict[0] == 'RequiresPlugin':
			msg = _("<b>%s</b> requires the plugin <b>%s</b>.")
			msg = msg % (plugin.ShortDesc, conflict[2][0].ShortDesc)

			okButton.set_label(_("Enable %s") % conflict[2][0].ShortDesc)
			cancelButton.set_label(_("Don't enable %s") % plugin.ShortDesc)
			
			dlg.set_markup(msg)
			dlg.show_all()
			ret = dlg.run()
			dlg.destroy()
			
			if ret ==  gtk.RESPONSE_OK:			
				enableConflicts = conflict[2][0].EnableConflicts
				if HandlePluginConflicts(conflict[2][0], enableConflicts):
					conflict[2][0].Enabled = True
				else:
					return False
			else:
				return False

		elif conflict[0] == 'FeatureNeeded':
			pluginList = ', '.join("\"%s\"" % plugin.ShortDesc for plugin in conflict[2])
			msg = _("<b>%s</b> provides the feature <b>%s</b> which is required by the plugins <b>%s</b>.")
			msg = msg % (plugin.ShortDesc, conflict[1], pluginList) 

			okButton.set_label(_("Disable these plugins"))
			cancelButton.set_label(_("Don't disable %s") % plugin.ShortDesc)
			
			dlg.set_markup(msg)
			dlg.show_all()
			ret = dlg.run()
			dlg.destroy()
			
			if ret == gtk.RESPONSE_OK:
				for plg in conflict[2]:
					disableConflicts = plg.DisableConflicts
					if HandlePluginConflicts(plg, disableConflicts):
						plg.Enabled = False
					else:
						return False
			else:
				return False

		elif conflict[0] == 'PluginNeeded':
			pluginList = ', '.join("\"%s\"" % plugin.ShortDesc for plugin in conflict[2])
			msg = _("<b>%s</b> is required by the plugins <b>%s</b>.")
			msg = msg % (plugin.ShortDesc, pluginList)

			okButton.set_label(_("Disable these plugins"))
			cancelButton.set_label(_("Don't disable %s") % plugin.ShortDesc)
			
			dlg.set_markup(msg)
			dlg.show_all()
			ret = dlg.run()
			dlg.destroy()

			if ret == gtk.RESPONSE_OK:
				for plg in conflict[2]:
					disableConflicts = plg.DisableConflicts
					if HandlePluginConflicts(plg, disableConflicts):
						plg.Enabled = False
					else:
						return False
			else:
				return False

	return True

class ActionItem(SettingItem):
	pass

def FirstItemSortCompare(sg1, sg2):
	return cmp(sg1[0], sg2[0])

class ActionPage:
	def __init__(self, plugin, filter = None):
		self.EdgeList = ['None', 'TopLeft', 'Top', 'TopRight', 'Left', 'Right', 'BottomLeft', 'Bottom', 'BottomRight']
		self.Widget = gtk.VBox()
		self.Plugin = plugin
		self.Filter = filter
		self.Context = context
		self.Scroll = gtk.ScrolledWindow()
		self.Scroll.props.hscrollbar_policy = gtk.POLICY_AUTOMATIC
		self.Scroll.props.vscrollbar_policy = gtk.POLICY_AUTOMATIC
		self.Store = gtk.TreeStore(
				gobject.TYPE_STRING, 	#0-Name
				gobject.TYPE_UINT, 		#1-Key
				gobject.TYPE_UINT, 		#2-KeyMods
				gobject.TYPE_STRING, 	#3-Button
				gobject.TYPE_STRING, 	#4-Edges
				gobject.TYPE_STRING,	#5-EdgeButton
				gobject.TYPE_BOOLEAN, 	#6-Visible/Editable
				gobject.TYPE_BOOLEAN, 	#7-Bell
				gobject.TYPE_BOOLEAN,   #8-KeyPossible
				gobject.TYPE_BOOLEAN,   #9-ButPossible
				gobject.TYPE_BOOLEAN,   #10-EdgePossible
				gobject.TYPE_BOOLEAN,   #11-BellPossible
				gobject.TYPE_STRING, 	#12-group
				gobject.TYPE_STRING, 	#13-subgroup
				gobject.TYPE_STRING, 	#14-setting
				gobject.TYPE_STRING, 	#15-plugin
				gobject.TYPE_STRING, 	#16-disp/scn str XXX
				)
		
		self.TreeView = gtk.TreeView(self.Store)
		self.TreeView.set_headers_visible(True)
		# Name
		self.TreeView.insert_column_with_attributes(-1, _("Name"), gtk.CellRendererText(), markup=0)
		# Key
		keyRenderer = gtk.CellRendererAccel()
		keyRenderer.connect('accel-edited', self.KeyEdited)
		keyRenderer.connect('accel-cleared', self.KeyCleared)
		self.TreeView.insert_column_with_attributes(-1, _("Key"), keyRenderer, accel_key=1, accel_mods=2, editable=8, visible=6, sensitive=8)
		# Button
		buttonRenderer = gtk.CellRendererText()
		buttonRenderer.connect('edited', self.ButtonEdited)
		self.TreeView.insert_column_with_attributes(-1, _("Button"), buttonRenderer, text=3, editable=9, visible=6, sensitive=9)
		# Edges
		edgeRenderer = gtk.CellRendererText()
		self.TreeView.insert_column_with_attributes(-1, _("Screen Edge"), edgeRenderer, text=4, visible=6, sensitive=10)
		# Edge Button
		self.EdgeButtonStore = gtk.ListStore(gobject.TYPE_STRING)
		for number in range(0, 6):
			iter = self.EdgeButtonStore.append()
			text = ""
			if number != 0:
				text = _("Button %i") % number
			else:
				text = _("None")
			self.EdgeButtonStore.set(iter, 0, text)
		edgeButtonRenderer = gtk.CellRendererCombo()
		edgeButtonRenderer.props.has_entry = False
		edgeButtonRenderer.props.model = self.EdgeButtonStore
		edgeButtonRenderer.props.text_column = 0
		edgeButtonRenderer.connect('edited', self.EdgeButtonEdited)
		self.TreeView.insert_column_with_attributes(-1, _("Edge Button"), edgeButtonRenderer, text=5, visible=6, editable=10, sensitive=10)
		# Bell -- may replace with one setting in general
		bellRenderer = gtk.CellRendererToggle()
		bellRenderer.props.xalign = 0
		bellRenderer.connect('toggled', self.BellEdited)
		self.TreeView.insert_column_with_attributes(-1, _("On System Bell"), bellRenderer, activatable=11, visible=6, sensitive=11, active=7) 
		
		for col in self.TreeView.get_columns():
			col.set_resizable(True)
		
		self.Scroll.add(self.TreeView)
		self.Widget.pack_start(self.Scroll, True, True)
		self.Empty = True
		self.TreeView.connect('row-activated', self.Activated)
		
		self.Plugins = {}
		if plugin:
			self.DoGroups(plugin.Groups, None, plugin.Name)
		else:
			for plugin in Context.Plugins.values():
				pluginIter = self.Store.append(None)
				self.Store.set(pluginIter, 0, plugin.ShortDesc, 6, False, 8, False, 9, False, 10, False, 11, False)
				if not self.DoGroups(plugin.Groups, pluginIter, plugin.Name):
					self.Store.remove(pluginIter)
	
	def DoGroups(self, groupList, iter, pluginName):
		self.Plugins[pluginName] = {}
		pluginEmpty = True
		
		for groupName, group in groupList.items():
			groupEmpty = True
			groupIter = self.Store.append(iter)
			name = (groupName == '' and _("General") or groupName)
			self.Store.set(groupIter, 0, name, 6, False, 8, False, 9, False, 10, False, 11, False)
			self.Plugins[pluginName][groupName] = {}

			subGroupsSorted = sorted(group.items(), FirstItemSortCompare)
			for subGroupName, subGroup in subGroupsSorted:
				if subGroupName != '':
					subGroupIter = self.Store.append(groupIter)
					self.Store.set(subGroupIter, 0, subGroupName, 6, False, 8, False, 9, False, 10, False, 11, False)
				self.Plugins[pluginName][groupName][subGroupName] = {}
				subGroupEmpty = True
				
				settings = sum((v.values() for v in [subGroup.Display]+[subGroup.Screens[CurrentScreenNum]]), [])
				settings = sorted(FilterSettings(settings, self.Filter), SettingSortCompare)
				for setting in settings:
					if setting.Type == 'Action':
						if subGroupName != '':
							i = self.Store.append(subGroupIter)
						else:
							i = self.Store.append(groupIter)

						key, mods = gtk.accelerator_parse(setting.Value[0])
						edges = 'None'
						if len(setting.Value[3]) > 0:
							edges = " | ".join(setting.Value[3])

						edgeButton = setting.Value[4]
						if edgeButton != 0:
							edgeButton = _("Button %i") % edgeButton
						else:
							edgeButton = _("None")

						markup = "%s"
						if setting.Integrated:
							markup = "<span color='blue'>%s</span>"
						
						self.Store.set(i, 0, markup % setting.ShortDesc, 1, key, 2, mods, 3, setting.Value[1], 4,
									   edges, 5, edgeButton, 6, True, 7, setting.Value[2], 8, setting.Info[0], 9, setting.Info[1], 10,
									   setting.Info[3], 11, setting.Info[2], 12, groupName, 13, subGroupName, 14,
									   setting.Name, 15, pluginName)
						self.Plugins[pluginName][groupName][subGroupName][setting.Name] = setting
						
						groupEmpty = False
						subGroupEmpty = False
						pluginEmpty = False
						self.Empty = False
				
				if subGroupEmpty:
					if subGroupName != '':
						self.Store.remove(subGroupIter)
			if groupEmpty:
				self.Store.remove(groupIter)
		
		return not pluginEmpty
	
	def Activated(self, object, path, col):
		def ResetButton(object, setting, iter):
			if setting.Info[0]:
				keyEntry.set_text(setting.DefaultValue[0])
			if setting.Info[1]:
				buttonEntry.set_text(setting.DefaultValue[1])
			if setting.Info[2]:
				bellButton.set_active(setting.DefaultValue[2])
			if setting.Info[3]:
				children = edgeTable.get_children()
				edges = setting.DefaultValue[3]
				for checkBox in children:
					checkBox.set_active(False)
					for edge in edges:
						if checkBox.get_label() == edge:
							checkBox.set_active(True)
							break
				edgeButtonCombo.set_active(setting.DefaultValue[4])

		iter = self.Store.get_iter(path)
		store = self.Store.get(iter, 12, 13, 14, 15, 1, 2, 3, 4, 5, 7)
		groupName, subGroupName, settingName, pluginName, key, keyModifier, button, edges, edgeButton, bell = store

		if subGroupName is None or groupName is None or settingName is None:
			if self.TreeView.row_expanded(path):
				self.TreeView.collapse_row(path)
			else:
				self.TreeView.expand_row(path, False)
			return

		edges = edges.split(" | ")
		setting = self.Plugins[pluginName][groupName][subGroupName][settingName]

		dlg = gtk.Dialog(_("Edit Action: %s") % setting.ShortDesc)
		dlg.add_button(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL)
		dlg.add_button(gtk.STOCK_OK, gtk.RESPONSE_OK).grab_default()
		dlg.set_default_response(gtk.RESPONSE_OK)
		table = gtk.Table()
		dlg.vbox.pack_start(table, False, False)
		
		# Key
		if setting.Info[0]:
			keyEntry = gtk.Entry()
			keyEntry.set_text(gtk.accelerator_name(key, keyModifier) or 'None')
			keyLabel = gtk.Label(_("Key"))
			keyLabel.props.xalign = 0
			table.attach(keyLabel, 0, 1, 0, 1, TDef, TDef, TXp, TYp)
			table.attach(keyEntry, 1, 2, 0, 1, TDef, TDef, TXp, TYp)
		
		# Button
		if setting.Info[1]:
			buttonEntry = gtk.Entry()
			buttonEntry.set_text(button)
			buttonLabel = gtk.Label(_("Button"))
			buttonLabel.props.xalign = 0
			table.attach(buttonLabel, 0, 1, 1, 2, TDef, TDef, TXp, TYp)
			table.attach(buttonEntry, 1, 2, 1, 2, TDef, TDef, TXp, TYp)
		
		# Edge + EdgeButton
		if setting.Info[3]:
			edgeTable = gtk.Table()
			row = 0
			col = 0
			for e in self.EdgeList:
				if e == 'None':
					continue
				
				edgeCheck = gtk.CheckButton(e)
				if edges.count(e) > 0:
					edgeCheck.set_active(True)
				edgeTable.attach(edgeCheck, col, col+1, row, row+1, TDef, TDef, TXp, TYp)

				col += 1
				if col > 2:
					row += 1
					col = 0

				if (row == 1 and col > 0):
					col += 1
					
			edgeLabel = gtk.Label(_("Screen Edges"))
			edgeLabel.props.xalign = 0
			table.attach(edgeLabel, 0, 1, 2, 3, TDef, TDef, TXp, TYp)
			table.attach(edgeTable, 1, 2, 2, 3, TDef, TDef, TXp, TYp)

			edgeButtonCombo = gtk.ComboBox(self.EdgeButtonStore)
			if edgeButton == _("None"):
				edgeButtonCombo.set_active(0)
			else:
				edgeButtonCombo.set_active(int(edgeButton[-1]))
			edgeButtonComboRenderer = gtk.CellRendererText()
			edgeButtonCombo.pack_start(edgeButtonComboRenderer)
			edgeButtonCombo.add_attribute(edgeButtonComboRenderer,'text',0)
			edgeButtonLabel = gtk.Label(_("Edge Button"))
			edgeButtonLabel.props.xalign = 0
			table.attach(edgeButtonLabel, 0, 1, 3, 4, TDef, TDef, TXp, TYp)
			table.attach(edgeButtonCombo, 1, 2, 3, 4, TDef, TDef, TXp, TYp)
		
		# Bell
		if setting.Info[2]:
			bellButton = gtk.CheckButton(_("On System Bell"))
			bellButton.set_active(bell)
			table.attach(bellButton, 0, 2, 4, 5, TDef, TDef, TXp, TYp)
		
		# Reset
		box = gtk.HBox()
		box.pack_start(MakeLabel(_("Reset To Defaults")), True, True)
		resetButton = gtk.Button()
		resetImage = gtk.Image()
		resetImage.set_from_stock(gtk.STOCK_CLEAR, gtk.ICON_SIZE_BUTTON)
		resetButton.set_image(resetImage)
		box.pack_end(resetButton, False, False)
		resetButton.connect('clicked', ResetButton, setting, iter)
		table.attach(box, 0, 2, 5, 6, TDef, TDef, TXp, TYp)
		
		dlg.show_all()
		resp = dlg.run()
		if setting.Info[0]:
			key = keyEntry.get_text()
		if setting.Info[1]:
			button = buttonEntry.get_text()
		if setting.Info[2]:
			bell = bellButton.get_active()
		if setting.Info[3]:
			children = edgeTable.get_children()
			edges = []
			for checkBox in children:
				if checkBox.get_active():
					edges.append(checkBox.get_label())
			edges = " | ".join(edges)
			edgeButton = edgeButtonCombo.get_active_text()
		
		dlg.destroy()
		if resp == gtk.RESPONSE_OK:
			if setting.Info[0]:
				akey, amods = gtk.accelerator_parse(key)
				self.Store.set(iter, 1, akey, 2, amods)
			if setting.Info[1]:
				self.Store.set(iter, 3, button)
			if setting.Info[2]:
				self.Store.set(iter, 7, bell)
			if setting.Info[3]:
				self.Store.set(iter, 4, edges)
				self.Store.set(iter, 5, edgeButton)
			self.WriteSetting(iter)
	
	def WriteSetting(self, iter):
		store = self.Store.get(iter, 12, 13, 14, 15, 1, 2, 3, 4, 5, 7)
		groupName, subGroupName, settingName, pluginName, key, keyModifier, button, edges, edgeButton, bell = store
		
		setting = self.Plugins[pluginName][groupName][subGroupName][settingName]
		realKey = gtk.accelerator_name(key, keyModifier)
		edges = edges.split(" | ")
		if edgeButton != _("None"):
			edgeButton = int(edgeButton[-1])
		else:
			edgeButton = 0

		if CheckActionConflicts(setting, realKey, button, bell, edges, edgeButton):
			setting.Value = [realKey, button, bell, edges, edgeButton]
			Write(setting.Plugin.Context)
			
		realKey, button, bell, edges, edgeButton = setting.Value
		key, keyModifier = gtk.accelerator_parse(realKey)
		if len(edges) > 0:
			edges = " | ".join(setting.Value[3])
		else:
			edges = 'None'
		if edgeButton != 0:
			edgeButton = _("Button %i") % edgeButton
		else:
			edgeButton = _("None")

		self.Store.set(iter, 1, key, 2, keyModifier, 3, button, 4, edges, 5, edgeButton, 7, bell)
	
	def KeyEdited(self, obj, path, key, mods, code):
		iter = self.Store.get_iter_from_string(path)
		self.Store.set(iter, 1, key, 2, mods)
		self.WriteSetting(iter)
	
	def KeyCleared(self, obj, path):
		iter = self.Store.get_iter_from_string(path)
		self.Store.set(iter, 1, 0, 2, 0)
		self.WriteSetting(iter)
	
	def ButtonEdited(self, obj, path, val):
		iter = self.Store.get_iter_from_string(path)
		self.Store.set(iter, 3, val)
		self.WriteSetting(iter)
	
	def EdgeEdited(self, obj, path, val):
		iter = self.Store.get_iter_from_string(path)
		self.Store.set(iter, 4, val)
		self.WriteSetting(iter)

	def EdgeButtonEdited(self, obj, path, val):
		iter = self.Store.get_iter_from_string(path)
		self.Store.set(iter, 5, val)
		self.WriteSetting(iter)
	
	def BellEdited(self, obj, path):
		iter = self.Store.get_iter_from_string(path)
		value = self.Store.get(iter, 7)[0]
		if value:
			value = False
		else:
			value = True
		self.Store.set(iter, 7, value)
		self.WriteSetting(iter)


def MakeLabel(value = None, wrap = 160):
	if value is not None:
		label = gtk.Label(value)
	else:
		label = gtk.Label()
	label.props.xalign = 0
	label.props.wrap_mode = gtk.WRAP_WORD
	label.set_line_wrap(True)
	label.set_size_request(wrap, -1)
	return label

class PluginClass:
	def __init__(self, plugin, main):
		self.Plugin = plugin
		self.LeftWidget = gtk.VBox(False, 10)
		self.LeftWidget.set_border_width(15)
		pluginLabel = MakeLabel()
		pluginLabel.set_markup("<span color='%s' size='large' weight='800'>%s</span>" % (main.BrightColor, plugin.ShortDesc))
		pluginImg = main.MakeImage(plugin, size = 64)
		filterLabel = MakeLabel()
		filterLabel.set_markup("<span color='%s' size='large' weight='800'>%s</span>" % (main.BrightColor, _("Filter")))
		if has_sexy:
			self.FilterEntry = sexy.IconEntry()
			self.FilterEntry.add_clear_button()
		else:
			self.FilterEntry = gtk.Entry()
		self.FilterEntry.connect("changed", self.FilterChanged)
		self.LeftWidget.pack_start(pluginImg, False, False)
		self.LeftWidget.pack_start(filterLabel, False, False)
		self.LeftWidget.pack_start(self.FilterEntry, False, False)
		self.LeftWidget.pack_start(pluginLabel, False, False)
		infoLabelCont = gtk.HBox()
		infoLabelCont.set_border_width(10)
		self.LeftWidget.pack_start(infoLabelCont, False, False)
		infoLabel = MakeLabel(plugin.LongDesc, 180)
		infoLabelCont.pack_start(infoLabel, True, True)
		
		if plugin.Name != 'core':
			Tooltips.set_tip(self.FilterEntry, _("Search %s Plugin Options") % plugin.ShortDesc)
			enableLabel = MakeLabel()
			enableLabel.set_markup("<span color='%s' size='large' weight='800'>%s</span>" % (main.BrightColor, _("Use This Plugin")))
			self.LeftWidget.pack_start(enableLabel, False, False)
			enableCheckCont = gtk.HBox()
			enableCheckCont.set_border_width(10)
			self.LeftWidget.pack_start(enableCheckCont, False, False)
			enableCheck = gtk.CheckButton()
			enableCheck.add(MakeLabel(_("Enable %s") % plugin.ShortDesc, 120))
			Tooltips.set_tip(enableCheck, plugin.LongDesc)
			enableCheck.set_active(plugin.Enabled)
			enableCheckCont.pack_start(enableCheck, True, True)
			enableCheck.connect('toggled', self.EnablePlugin)
		else:
			Tooltips.set_tip(self.FilterEntry, _("Search Compiz Core Options"))
		
		backButton = gtk.Button(gtk.STOCK_GO_BACK)
		backButton.set_use_stock(True)
		self.LeftWidget.pack_end(backButton, False, False)
		backButton.connect('clicked', main.BackToMain)
		self.RightWidget = gtk.Notebook()
		self.Pages = []

		groupsSorted = sorted(plugin.Groups.items(), FirstItemSortCompare)
		for name, group in groupsSorted:
			name = name or _("General")
			groupPage = GroupPage(name, group)
			if not groupPage.Empty:
				self.RightWidget.append_page(groupPage.Widget, gtk.Label(name))
				self.Pages = self.Pages + [groupPage]
		
		actionPage = ActionPage(plugin)
		if not actionPage.Empty:
			self.RightWidget.append_page(actionPage.Widget, gtk.Label(_("Actions")))
			self.Pages = self.Pages + [actionPage]
		else:
			self.RightWidget.connect('size-allocate', self.ResetFocus)

		self.Block = 0

	def ResetFocus(self, widget, data):
		pos = self.FilterEntry.get_position() 
		self.FilterEntry.grab_focus()
		self.FilterEntry.set_position(pos)

	def FilterChanged(self, widget):
		filter = widget.get_text().lower()
		if filter == "":
			filter = None

		groups = []

		for name, group in self.Plugin.Groups.items():
			name = name or _("General")
			groupPage = GroupPage(name, group, filter)
			if not groupPage.Empty:
				groups.append((name, groupPage))

		for page in self.RightWidget.get_children():
			self.RightWidget.remove_page(self.RightWidget.page_num(page))
			page.destroy()

		for name, groupPage in groups:
			self.RightWidget.append_page(groupPage.Widget, gtk.Label(name))
		
		actionPage = ActionPage(self.Plugin, filter)
		if not actionPage.Empty:
			self.RightWidget.append_page(actionPage.Widget, gtk.Label(_("Actions")))

		self.RightWidget.show_all()

	def EnablePlugin(self, widget):
		if self.Block > 0:
			return
		self.Block += 1
		# attempt to resolve conflicts...
		conflicts = self.Plugin.Enabled and self.Plugin.DisableConflicts or self.Plugin.EnableConflicts
		if HandlePluginConflicts(self.Plugin, conflicts):
			self.Plugin.Enabled = widget.get_active()
		else:
			widget.set_active(self.Plugin.Enabled)
		Write(self.Plugin.Context)
		self.Block = self.Block-1

class SelectorButtons(gtk.HBox):
	def __init__(self):
		gtk.HBox.__init__(self)
		self.set_border_width(10)
		self.set_spacing(5)
		self.Buttons = []
		self.Arrows = []

	def add_button(self, label, callback):
		arrow = gtk.Arrow(gtk.ARROW_RIGHT, gtk.SHADOW_NONE)
		button = gtk.Button(label)
		button.set_relief(gtk.RELIEF_NONE)
		button.connect('clicked', callback, label)
		if len(self.get_children()) > 0:
			self.pack_start(arrow, False, False)
			self.Arrows.append(arrow)
		self.pack_start(button, False, False)
		self.Buttons.append(button)
		self.show_all()

	def remove_button(self, pos):
		if pos > len(self.Buttons)-1:
			return
		self.Buttons[pos].destroy()
		self.Buttons.remove(self.Buttons[pos])
		if pos > 0:
			self.Arrows[pos-1].destroy()
			self.Arrows.remove(self.Arrows[pos-1])

class SelectorBox(gtk.ScrolledWindow):
	def __init__(self, main):
		gtk.ScrolledWindow.__init__(self)
		self.SelectedItem = None
		self.Viewport = gtk.Viewport()
		self.Viewport.modify_bg(gtk.STATE_NORMAL, gtk.gdk.color_parse(main.BackgroundColor))
		self.props.hscrollbar_policy = gtk.POLICY_NEVER
		self.props.vscrollbar_policy = gtk.POLICY_AUTOMATIC
		self.set_size_request(210, 150)
		self.Box = gtk.VBox()
		self.Box.set_spacing(5)
		self.Viewport.add(self.Box)
		self.add(self.Viewport)

	def close(self):
		self.destroy()
		self.Viewport.destroy()
		for button in self.Box.get_children():
			button.destroy()
		self.Box.destroy()

	def add_item(self, item, callback):
		button = gtk.Button()
		label = MakeLabel(item or _("General"))
		button.add(label)
		button.connect("clicked", callback, item)
		button.set_relief(gtk.RELIEF_NONE)
		self.Box.pack_start(button, False, False)

	def clear_list(self):
		for button in self.Box.get_children():
			button.destroy()
	
	def set_item_list(self, list, callback):
		self.clear_list()
		for item in list:
			self.add_item(item)
			
		self.Box.show_all()

def PluginSortCompare(p1, p2):
	return cmp(p1.ShortDesc, p2.ShortDesc)

class FilterPage:
	def __init__(self, main, context):
		self.Context = context
		self.Main = main
		self.MainWin = main.MainWin
		self.LeftWidget = gtk.VBox(False, 10)
		self.LeftWidget.set_border_width(15)
		self.RightWidget = gtk.Notebook()
		self.RightChild = gtk.VBox()

		# Image + Label
		filterLabel = MakeLabel()
		filterLabel.set_markup("<span color='%s' size='large' weight='800'>%s</span>" % (main.BrightColor, _("Filter")))
		filterImg = main.MakeImage(category="search", size = 64)
		self.LeftWidget.pack_start(filterImg, False, False)
		self.LeftWidget.pack_start(filterLabel, False, False)
		
		# Entry
		if has_sexy:
			filterEntry = sexy.IconEntry()
			filterEntry.add_clear_button()
		else:
			filterEntry = gtk.Entry()
		filterEntry.connect("changed", self.FilterChanged)
		self.LeftWidget.pack_start(filterEntry, False, False)

		# Search in...
		filterSearchLabel = MakeLabel()
		filterSearchLabel.set_markup("<span color='%s' size='large' weight='800'>%s</span>" % (main.BrightColor, _("Search in...")))
		self.LeftWidget.pack_start(filterSearchLabel, False, False)

		# Options
		self.FilterName = gtk.CheckButton()
		filterLabel = MakeLabel(_("Short description and name"))
		self.FilterName.add(filterLabel)
		self.FilterName.set_active(True)
		
		self.FilterLongDesc = gtk.CheckButton()
		filterLabel = MakeLabel(_("Long description"))
		self.FilterLongDesc.add(filterLabel)
		self.FilterLongDesc.set_active(True)
		
		self.FilterValue = gtk.CheckButton()
		filterLabel = MakeLabel(_("Settings value"))
		self.FilterValue.add(filterLabel)
		self.FilterValue.set_active(False)

		self.LeftWidget.pack_start(self.FilterName, False, False)
		self.LeftWidget.pack_start(self.FilterLongDesc, False, False)
		self.LeftWidget.pack_start(self.FilterValue, False, False)

		# Back Button
		self.BackButton = gtk.Button(gtk.STOCK_GO_BACK)
		self.BackButton.set_use_stock(True)
		self.BackButton.connect('clicked', self.Main.BackToMain)
		self.LeftWidget.pack_end(self.BackButton, False, False)

		self.FilteredPlugins = []
		self.Filter = None

		# Selector
		self.CurrentPlugin = None
		self.CurrentGroup = None
		self.CurrentSubGroup = None
		self.SelectorButtons = SelectorButtons()
		self.PluginBox = SelectorBox(main)
		self.GroupBox = SelectorBox(main)
		self.SubGroupBox = SelectorBox(main)
		self.SelectorBoxes = gtk.HBox()
		self.SelectorBoxes.set_border_width(5)
		self.SelectorBoxes.set_spacing(5)
		self.PluginBox.set_no_show_all(True)
		self.GroupBox.set_no_show_all(True)
		self.SubGroupBox.set_no_show_all(True)
		self.SelectorBoxes.pack_start(self.PluginBox, False, False)
		self.SelectorBoxes.pack_start(self.GroupBox, False, False)
		self.SelectorBoxes.pack_start(self.SubGroupBox, False, False)
		self.RightChild.pack_start(self.SelectorButtons, False, False)
		self.RightChild.pack_start(self.SelectorBoxes, False, False)
		self.SettingsArea = gtk.ScrolledWindow()
		viewport = gtk.Viewport()
		self.SettingsBox = gtk.VBox()
		self.SettingsBox.set_border_width(5)
		self.SettingsBox.set_spacing(5)
		viewport.add(self.SettingsBox)
		self.SettingsArea.props.hscrollbar_policy = gtk.POLICY_NEVER
		self.SettingsArea.props.vscrollbar_policy = gtk.POLICY_AUTOMATIC
		self.SettingsArea.set_border_width(5)
		self.SettingsArea.add(viewport)
		self.SettingsArea.set_no_show_all(True)
		self.RightChild.pack_start(self.SettingsArea, True, True)

		self.FilterChanged(filterEntry)

		# Notebool
		self.RightWidget.append_page(self.RightChild, gtk.Label(_("Settings")))

	def UpdateBoxes(self):
		self.PluginBox.clear_list()
		self.GroupBox.clear_list()
		self.SubGroupBox.clear_list()
		for child in self.SettingsBox.get_children():
			child.destroy()

		singleGroup = None
		singleSubGroup = None
		
		# Plugins
		for plugin, groups in self.FilteredPlugins:
			self.PluginBox.add_item(plugin.ShortDesc, self.PluginChanged)
			# Groups
			if self.CurrentPlugin == plugin.ShortDesc:
				if len(groups) == 1:
					singleGroup = groups[0][0]

				groupsSorted = sorted(groups, FirstItemSortCompare)
				for group, subGroups in groupsSorted:
					self.GroupBox.add_item(group, self.GroupChanged)
					# SubGroups
					if self.CurrentGroup == group or singleGroup == group:
						if len(subGroups) == 1:
							singleSubGroup = subGroups[0][0]

						subGroupsSorted = sorted(subGroups, FirstItemSortCompare)
						for name, subGroup, settings in subGroupsSorted:
							self.SubGroupBox.add_item(name, self.SubGroupChanged)
							# Settings
							if self.CurrentSubGroup == name:
								sga = SubGroupArea('', subGroup, self.Filter)
								self.SettingsBox.pack_start(sga.Widget, False, False)
							elif self.CurrentSubGroup == None:
								sga = SubGroupArea(name, subGroup, self.Filter)
								self.SettingsBox.pack_start(sga.Widget, False, False)

		if len(self.FilteredPlugins) == 0:
			self.CurrentPlugin = None
			self.CurrentGroup = None
			self.CurrentSubGroup = None

		self.PluginBox.hide()
		self.PluginBox.set_no_show_all(len(self.FilteredPlugins) == 0)
		self.GroupBox.hide()
		self.GroupBox.set_no_show_all(self.CurrentPlugin == None or singleGroup != None)
		self.SubGroupBox.hide()
		self.SubGroupBox.set_no_show_all(self.CurrentGroup == None or singleSubGroup != None)
		self.SettingsArea.hide()
		self.SettingsArea.set_no_show_all(len(self.SettingsBox.get_children()) == 0)

		self.RightChild.show_all()

		if self.CurrentPlugin != None and singleGroup != None:
			self.CurrentGroup = singleGroup

		if self.CurrentGroup != None and singleSubGroup != None:
			self.CurrentSubGroup = singleSubGroup

	def PluginChanged(self, widget, plugin):
		if self.CurrentSubGroup != None:
			self.SelectorButtons.remove_button(2)
		if self.CurrentGroup != None:
			self.SelectorButtons.remove_button(1)
		if self.CurrentPlugin != None:
			self.SelectorButtons.remove_button(0)

		self.CurrentPlugin = plugin
		self.CurrentGroup = None
		self.CurrentSubGroup = None

		self.SelectorButtons.add_button(plugin, self.PluginChanged)
		self.UpdateBoxes()

	def GroupChanged(self, widget, group):
		if self.CurrentSubGroup != None:
			self.SelectorButtons.remove_button(2)
		if self.CurrentGroup != None:
			self.SelectorButtons.remove_button(1)

		self.CurrentGroup = group
		self.CurrentSubGroup = None

		self.SelectorButtons.add_button(group or _("General"), self.GroupChanged)
		self.UpdateBoxes()

	def SubGroupChanged(self, widget, subGroup):
		if self.CurrentGroup != None:
			self.SelectorButtons.remove_button(2)

		self.CurrentSubGroup = subGroup

		self.SelectorButtons.add_button(subGroup or _("General"), self.SubGroupChanged)
		self.UpdateBoxes()

	def FilterChanged(self, widget):
		self.Filter = widget.get_text()
		runLevels = []
		if self.FilterName.get_active():
			runLevels.append(0)
		if self.FilterLongDesc.get_active():
			runLevels.append(1)
		if self.FilterValue.get_active():
			runLevels.append(2)
		plugins = []
		for plugin in sorted(self.Context.Plugins.values(), PluginSortCompare):
			groups = []
			for group in plugin.Groups:
				subGroups = []
				for name, subGroup in plugin.Groups[group].items():
					settings = sum((v.values() for v in [subGroup.Display]+[subGroup.Screens[CurrentScreenNum]]), [])
					settings = sorted(settings, SettingSortCompare)
					settings = FilterSettings(settings, self.Filter, run=runLevels, noActions=True, singleRun=True)
					if len(settings) > 0:
						subGroups.append((name, subGroup, settings))
				if len(subGroups) > 0:
					groups.append((group, subGroups))
			if len(groups) > 0:
				plugins.append((plugin, groups))

		self.FilteredPlugins = plugins
		self.UpdateBoxes()
		
		
class ProfileBackendPage:
	def __init__(self, main, context):
		self.Context = context
		self.Main = main
		self.MainWin = main.MainWin
		self.LeftWidget = gtk.VBox(False, 10)
		self.LeftWidget.set_border_width(15)
		self.RightWidget = gtk.Notebook()
		rightChild = gtk.VBox()
		rightChild.set_border_width(10)
		self.RightWidget.append_page(rightChild, gtk.Label(_("Profile & Backend")))

		# Left Pane
		self.DescLabel = MakeLabel()
		self.DescLabel.set_markup("<span color='%s' size='large' weight='800'>%s</span>" % (main.BrightColor, _("Backend &amp; Profile")))
		self.DescImg = main.MakeImage(category="profiles", size = 64)
		self.LeftWidget.pack_start(self.DescImg, False, False)
		self.LeftWidget.pack_start(self.DescLabel, False, False)
		self.InfoLabelCont = gtk.HBox()
		self.InfoLabelCont.set_border_width(10)
		self.LeftWidget.pack_start(self.InfoLabelCont, False, False)
		self.InfoLabel = MakeLabel(_("Configure the backend and profile used by the Compiz Configuration System."), 180)
		self.InfoLabelCont.pack_start(self.InfoLabel, True, True)

		# Profiles
		profileBox = gtk.HBox()
		profileBox.set_spacing(5)
		profileAdd = gtk.Button()
		Tooltips.set_tip(profileAdd, _("Add a New Profile"))
		profileAdd.set_image(gtk.image_new_from_stock(gtk.STOCK_ADD, gtk.ICON_SIZE_BUTTON))
		profileRemove = gtk.Button()
		Tooltips.set_tip(profileRemove, _("Remove This Profile"))
		profileRemove.set_image(gtk.image_new_from_stock(gtk.STOCK_REMOVE, gtk.ICON_SIZE_BUTTON))
		self.ProfileComboBox = gtk.combo_box_new_text()
		self.ProfileComboBox.set_sensitive(self.Context.CurrentBackend.ProfileSupport)
		self.ProfileComboBox.append_text(_("Default"))
		for profile in self.Context.Profiles.values():
			self.ProfileComboBox.append_text(profile.Name)
		if self.Context.CurrentProfile.Name == '':
			self.ProfileComboBox.set_active(0)
		else:
			name = self.Context.CurrentProfile.Name
			index = self.Context.Profiles.values().index(self.Context.Profiles[name])
			self.ProfileComboBox.set_active(index+1)
		self.ProfileComboBox.connect("changed", self.ProfileChanged)
		profileAdd.connect("clicked", self.AddProfile)
		profileRemove.connect("clicked", self.RemoveProfile)
		profileBox.pack_start(self.ProfileComboBox, True, True)
		profileBox.pack_start(profileAdd, False, False)
		profileBox.pack_start(profileRemove, False, False)
		profileLabel = MakeLabel()
		profileLabel.set_markup("<span color='%s' size='large' weight='800'>%s</span>" % (self.Main.BrightColor, _("Profile")))
		self.ProfileImportExportBox = gtk.HBox()
		self.ProfileImportExportBox.set_spacing(5)
		profileImportButton = gtk.Button(_("Import"))
		Tooltips.set_tip(profileImportButton, _("Import a CompizConfig Profile"))
		profileExportButton = gtk.Button(_("Export"))
		Tooltips.set_tip(profileExportButton, _("Export your CompizConfig Profile"))
		profileImportButton.set_image(gtk.image_new_from_stock(gtk.STOCK_OPEN, gtk.ICON_SIZE_BUTTON))
		profileExportButton.set_image(gtk.image_new_from_stock(gtk.STOCK_SAVE, gtk.ICON_SIZE_BUTTON))
		profileImportButton.connect("clicked", self.ImportProfile)
		profileExportButton.connect("clicked", self.ExportProfile)
		self.ProfileImportExportBox.pack_start(profileImportButton, False, False)
		self.ProfileImportExportBox.pack_start(profileExportButton, False, False)
		rightChild.pack_start(profileLabel, False, False, 5)
		rightChild.pack_start(profileBox, False, False, 5)
		rightChild.pack_start(self.ProfileImportExportBox, False, False, 5)

		# Backends
		backendBox = gtk.combo_box_new_text()
		for backend in self.Context.Backends.values():
			backendBox.append_text(backend.ShortDesc)
		name = self.Context.CurrentBackend.Name
		index = self.Context.Backends.values().index(self.Context.Backends[name])
		backendBox.set_active(index)
		backendBox.connect("changed", self.BackendChanged)
		backendLabel = MakeLabel()
		backendLabel.set_markup("<span color='%s' size='large' weight='800'>%s</span>" % (self.Main.BrightColor, _("Backend")))
		rightChild.pack_start(backendLabel, False, False, 5)
		rightChild.pack_start(backendBox, False, False, 5)

		# Integration
		integrationLabel = MakeLabel()
		integrationLabel.set_markup("<span color='%s' size='large' weight='800'>%s</span>" % (self.Main.BrightColor, _("Integration")))
		self.IntegrationButton = gtk.CheckButton(_("Enable integration into the desktop environment"))
		self.IntegrationButton.set_active(self.Context.Integration)
		self.IntegrationButton.set_sensitive(self.Context.CurrentBackend.IntegrationSupport)
		self.IntegrationButton.connect("toggled", self.IntegrationChanged)
		rightChild.pack_start(integrationLabel, False, False, 5)
		rightChild.pack_start(self.IntegrationButton, False, False, 5)		

		# Back Button
		self.BackButton = gtk.Button(gtk.STOCK_GO_BACK)
		self.BackButton.set_use_stock(True)
		self.BackButton.connect('clicked', self.Main.BackToMain)
		self.LeftWidget.pack_end(self.BackButton, False, False)
	
	def UpdateProfiles(self, default = _("Default")):
		self.Context.Read()
		self.Context.UpdateProfiles()

		self.ProfileComboBox.get_model().clear()
		self.ProfileComboBox.append_text(_("Default"))
		for profile in self.Context.Profiles.values():
			self.ProfileComboBox.append_text(profile.Name)

		index = -1
		counter = 0
		for m in self.ProfileComboBox.get_model():
			if m[0] == default:
				index=counter
			counter += 1
		if index >= 0:
			self.ProfileComboBox.set_active(index)

	def IntegrationChanged(self, widget):
		value = widget.get_active()
		self.Context.Integration = value

	def ProfileChanged(self, widget):
		name = widget.get_active_text()
		if name == _("Default"):
			self.Context.ResetProfile()
		else:
			self.Context.CurrentProfile = self.Context.Profiles[name]
		
		self.Context.Read()
		Write(self.Context)

	def CreateFilter(self, chooser):
		filter = gtk.FileFilter()
		filter.add_pattern("*.profile")
		filter.set_name(_("Profiles (*.profile)"))
		chooser.add_filter(filter)

		filter = gtk.FileFilter()
		filter.add_pattern("*")
		filter.set_name(_("All files"))
		chooser.add_filter(filter)
	
	def ExportProfile(self, widget):
		b = (gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL, gtk.STOCK_SAVE, gtk.RESPONSE_OK)
		chooser = gtk.FileChooserDialog(title=_("Save file.."), parent=mainWin, buttons=b, action=gtk.FILE_CHOOSER_ACTION_SAVE)
		chooser.set_current_folder(os.environ.get("HOME"))
		self.CreateFilter(chooser)
		ret = chooser.run()

		path = chooser.get_filename()
		chooser.destroy()
		if ret == gtk.RESPONSE_OK:
			self.Context.Export(path)

	def ImportProfile(self, widget):
		b = (gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL, gtk.STOCK_OPEN, gtk.RESPONSE_OK)
		chooser = gtk.FileChooserDialog(title=_("Open file.."), parent=mainWin, buttons=b)
		chooser.set_current_folder(os.environ.get("HOME"))
		self.CreateFilter(chooser)
		ret = chooser.run()

		path = chooser.get_filename()
		chooser.destroy()
		if ret == gtk.RESPONSE_OK:
			self.Context.Import(path)

	def AddProfile(self, widget):
		dlg = gtk.Dialog(_("Enter a profile name"), self.MainWin, gtk.DIALOG_MODAL)
		dlg.add_button(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL)
		dlg.add_button(gtk.STOCK_OK, gtk.RESPONSE_OK)
		
		entry = gtk.Entry()
		label = gtk.Label(_("Please enter a name for the new profile:"))
		dlg.vbox.pack_start(label, False, False, 5)
		dlg.vbox.pack_start(entry, False, False, 5)

		dlg.set_size_request(340, 120)
		dlg.show_all()
		ret = dlg.run()
		if ret == gtk.RESPONSE_OK:
			self.Context.CurrentProfile = ccs.Profile(self.Context, entry.get_text())
			self.UpdateProfiles(entry.get_text())
		dlg.destroy()
	
	def RemoveProfile(self, widget):
		name = self.ProfileComboBox.get_active_text()
		if name != _("Default"):
			self.Context.ResetProfile()
			self.Context.Profiles[name].Delete()
			self.UpdateProfiles()
	
	def BackendChanged(self, widget):
		shortDesc = widget.get_active_text()
		name = ""
		for backend in self.Context.Backends.values():
			if backend.ShortDesc == shortDesc:
				name = backend.Name
				break
		
		if name != "":
			self.Context.ResetProfile()
			self.Context.CurrentBackend = self.Context.Backends[name]
			self.UpdateProfiles()
		else:
			raise Exception, _("Backend not found.")

		self.ProfileComboBox.set_sensitive(self.Context.CurrentBackend.ProfileSupport)
		self.IntegrationButton.set_sensitive(self.Context.CurrentBackend.IntegrationSupport)

def Quit(foo):
	gtk.main_quit()

class MainWinClass:
	def __init__(self, Context):
		self.ShowingPlugin = None
		self.Context = Context
		self.MainWin = gtk.Window()
		self.MainWin.connect("destroy", Quit)
		self.MainWin.set_default_size(960, 580)
		self.MainWin.set_title(_("CompizConfig Settings Manager"))
		try:
			self.MainWin.set_icon (gdk.pixbuf_new_from_file(IconDir+"/apps/ccsm.svg"))
		except:
			pass
		# set up the Entry to get the BrightColor
		styleWidget = gtk.Entry()
		self.MainWin.add(styleWidget)
		styleWidget.realize()
		bc = styleWidget.style.bg[gtk.STATE_SELECTED]
		self.BrightColor = "#%.4x%.4x%.4x" % (bc.red, bc.green, bc.blue)
		bc = styleWidget.style.light[gtk.STATE_NORMAL]
		self.BackgroundColor = "#%.4x%.4x%.4x" % (bc.red, bc.green, bc.blue)
		self.MainWin.remove(styleWidget)
		styleWidget.destroy()
		
		# build the panes
		self.MainBox = gtk.HBox()
		self.MainWin.add(self.MainBox)
		self.LeftPane = gtk.Alignment()
		self.LeftPane.set_size_request(230, 520)
		self.RightPane = gtk.Alignment()
		self.RightPane.set_border_width(5)
		self.RightPane.props.yscale = 1
		self.RightPane.props.xscale = 1
		self.RightPane.props.xalign = 0
		self.RightPane.props.yalign = 0
		self.LeftPane.props.yscale = 1
		self.LeftPane.props.xscale = 1
		self.LeftPane.props.xalign = 0
		self.LeftPane.props.yalign = 0
		self.MainBox.pack_start(self.LeftPane, False, False)
		self.MainBox.pack_start(self.RightPane, True, True)
		self.Categories = {}
		self.PluginImages = {}
		self.RightVadj = 0.0
		
		for pluginName, plugin in self.Context.Plugins.items():
			self.PluginImages[pluginName] = self.MakeImage(plugin)
		
		for category in sorted(self.Context.Categories, self.CatSortCompare):
			self.Categories[category] = []
			for pluginName, plugin in self.Context.Plugins.items():
				if plugin.Category == category:
					self.Categories[category].append(plugin)
		
		self.BlockEnablePlugin = 0
		self.ResetMainWidgets()

	def ResetMainWidgets(self):
		pluginsVPort = gtk.Viewport()
		leftChild = gtk.VBox(False, 10)
		leftChild.set_border_width(15)
		
		# Filter
		filterLabel = MakeLabel()
		filterLabel.set_markup("<span color='%s' size='large' weight='800'>%s</span>" % (self.BrightColor, _("Filter")))
		filterLabel.props.xalign = 0.1
		if has_sexy:
			filterEntry = sexy.IconEntry()
			filterEntry.add_clear_button()
		else:
			filterEntry = gtk.Entry()
		Tooltips.set_tip(filterEntry, _("Filter your Plugin list"))
		filterEntry.connect("changed", self.FilterTable)
		leftChild.pack_start(filterLabel, False, False)
		leftChild.pack_start(filterEntry, False, False)

		# Screens
		if len(getScreens()) > 1:
			screenBox = gtk.combo_box_new_text()
			for screen in getScreens():
				screenBox.append_text(_("Screen %i") % screen)
			name = self.Context.CurrentBackend.Name
			screenBox.set_active(CurrentScreenNum)
			screenBox.connect("changed", self.ScreenChanged)
			screenLabel = MakeLabel()
			screenLabel.set_markup("<span color='%s' size='large' weight='800'>%s</span>" % (self.BrightColor, _("Screen")))
			leftChild.pack_start(screenLabel, False, False)
			leftChild.pack_start(screenBox, False, False)

		# Categories
		categoryBox = gtk.VBox()
		categoryBox.set_border_width(10)
		for category in sorted(self.Categories, self.CatSortCompare):
			name = category or _("Uncategorized")
			categoryToggleLabel = MakeLabel(name)
			categoryToggle = gtk.Button()
			categoryToggle.set_relief(gtk.RELIEF_NONE)
			categoryToggle.add(categoryToggleLabel)
			categoryToggle.connect("clicked", self.ToggleCategory, category)
			categoryBox.pack_start(categoryToggle, False, False)
		categoryLabel = MakeLabel()
		categoryLabel.props.xalign = 0.1
		categoryLabel.set_markup("<span color='%s' size='large' weight='800'>%s</span>" % (self.BrightColor, _("Category")))
		leftChild.pack_start(categoryLabel, False, False)
		leftChild.pack_start(categoryBox, False, False)

		# Exit Button
		exitButton = gtk.Button(gtk.STOCK_CLOSE)
		exitButton.set_use_stock(True)
		exitButton.connect('clicked', Quit)

		# About Button
		aboutButton = gtk.Button()
		Tooltips.set_tip(aboutButton, _("About"))
		aboutButton.connect('clicked', self.ShowAboutDialog)
		aboutImage = gtk.Image()
		aboutImage.set_size_request(24, -1)
		aboutImage.set_from_stock(gtk.STOCK_ABOUT, gtk.ICON_SIZE_BUTTON)
		aboutButton.add(aboutImage)

		# Exit/About Frame
		aboutExitFrame = gtk.HBox()
		aboutExitFrame.set_spacing(5)
		aboutExitFrame.pack_start(exitButton, True, True)
		aboutExitFrame.pack_start(aboutButton, False, False)
		leftChild.pack_end(aboutExitFrame, False, False)

		# Profiles and Backend
		profBackLabel = MakeLabel()
		profBackLabel.set_markup("<span color='%s' size='large' weight='800'>%s</span>" % (self.BrightColor, _("Backend &amp; Profile")))
		profBackImage = gtk.Image()
		profBackImage.set_from_stock(gtk.STOCK_GO_FORWARD, gtk.ICON_SIZE_BUTTON)
		profBackButton = gtk.Button()
		profBackButton.connect("clicked", self.ShowProfileBackend)
		profBackButton.set_relief(gtk.RELIEF_NONE)
		profBackFrame = gtk.HBox()
		profBackFrame.pack_start(profBackLabel, False, False)
		profBackFrame.pack_end(profBackImage, False, False)
		profBackButton.add(profBackFrame)
		leftChild.pack_end(profBackButton, False, False)

		# Advanced Search
		searchLabel = MakeLabel()
		searchLabel.set_markup("<span color='%s' size='large' weight='800'>%s</span>" % (self.BrightColor, _("Advanced Search")))
		searchImage = gtk.Image()
		searchImage.set_from_stock(gtk.STOCK_GO_FORWARD, gtk.ICON_SIZE_BUTTON)
		searchButton = gtk.Button()
		searchButton.connect("clicked", self.ShowAdvancedFilter)
		searchButton.set_relief(gtk.RELIEF_NONE)
		searchFrame = gtk.HBox()
		searchFrame.pack_start(searchLabel, False, False)
		searchFrame.pack_end(searchImage, False, False)
		searchButton.add(searchFrame)
		leftChild.pack_end(searchButton, False, False)

		pluginsVPort.modify_bg(gtk.STATE_NORMAL, gtk.gdk.color_parse(self.BackgroundColor))
		rightChild = gtk.ScrolledWindow()
		rightChild.props.hscrollbar_policy = gtk.POLICY_NEVER
		rightChild.props.vscrollbar_policy = gtk.POLICY_AUTOMATIC
		rightChild.set_size_request(280,-1)
		rightChild.add(pluginsVPort)
		self.BuildTable(pluginsVPort)
		rightChild.connect('size-allocate', self.RebuildTable)
		self.SetMainWidgets(leftChild, rightChild)

	def BuildTable(self, viewPort):
		pluginWindow = gtk.VBox()
		pluginWindow.set_border_width(10)
		viewPort.add(pluginWindow)

		self.TableCats = {}
		self.TableAttached = False
		self.LastCols = -1
		for category in sorted(self.Categories, self.CatSortCompare):
			pluginList = sorted(self.Categories[category], PluginSortCompare)
			categoryBox = gtk.VBox()
			categoryHeader = gtk.HBox()
			categoryHeader.set_spacing(10)
			categoryLabel = MakeLabel('', -1)
			pluginWindow.pack_start(categoryBox, False, False)

			name = category or _("Uncategorized")
			categoryLabel.set_markup("<span color='#aaa' size='x-large' weight='800'>%s</span>" % name)
			categoryImg = self.MakeImage(category = name.lower().replace(" ", "_"))
			if categoryImg:
				categoryHeader.pack_start(categoryImg, False, False)
			categoryHeader.pack_start(categoryLabel, False, False)
			categoryBox.pack_start(categoryHeader, False, False)
			
			categoryTab = gtk.Table()
			categoryTab.set_border_width(10)
			self.TableCats[category] = (categoryTab, [], [])
			categoryBox.pack_start(categoryTab, False, False)
			
			for plugin in pluginList:
				pluginButton = gtk.Button()
				pluginButton.connect('clicked', self.ShowPlugin, plugin)
				pluginButton.set_size_request(200, -1)
				pluginButton.set_relief(gtk.RELIEF_NONE)
				pluginButtonBox = gtk.HBox(False, 10)
				pluginButtonBox.set_border_width(10)
				pluginImage = self.PluginImages[plugin.Name]
				pluginLabel = MakeLabel(plugin.ShortDesc, 120)
				pluginButtonBox.pack_start(pluginImage, False, False)
				pluginButtonBox.pack_start(pluginLabel, True, True)
				pluginButton.add(pluginButtonBox)
				pluginBox = gtk.HBox()

				if plugin.Name !=  'core':
					pluginEnable = gtk.CheckButton()
					Tooltips.set_tip(pluginEnable, _("Enable %s") % plugin.ShortDesc)
					pluginEnable.set_active(plugin.Enabled)
					pluginEnable.connect("toggled", self.EnablePlugin, plugin)
					pluginBox.pack_start(pluginEnable, False, False)

				Tooltips.set_tip(pluginButton, plugin.LongDesc)
				pluginBox.pack_start(pluginButton, True, True)
				pluginBox.set_size_request(220, -1)
				self.TableCats[category][1].append(pluginBox)
				self.TableCats[category][2].append(plugin)

	# targets:
	# 0 = plugin name and short description
	# 1 = plugin long description
	# 2 = category
	def FilterTable(self, widget, target=0):
		text = widget.get_text().lower()
		cols = self.LastCols
		foundPlugin = False

		if self.TableAttached:
			for categoryName, categoryContainer in self.TableCats.items():
				for pluginButton in categoryContainer[1]:
					if pluginButton.get_parent():
						categoryContainer[0].remove(pluginButton)

		for categoryName, categoryContainer in self.TableCats.items():
			col = 0
			row = 0
			empty = True
			for pluginButton in categoryContainer[1]:
				index = categoryContainer[1].index(pluginButton)
				shortDesc = categoryContainer[2][index].ShortDesc.lower()
				longDesc = categoryContainer[2][index].LongDesc.lower()
				name = categoryContainer[2][index].Name.lower()
				category = categoryName.lower()
				show = False

				if target == 0:
					show = name.find(text) != -1 \
					or shortDesc.find(text) != -1
				elif target == 1:
					show = name.find(text) != -1 \
					or shortDesc.find(text) != -1 \
					or longDesc.find(text) != -1
				elif target == 2:
					show = category.find(text) != -1

				if show:
					empty = False
					foundPlugin = True
					categoryContainer[0].attach(pluginButton, col, col+1, row, row+1, 0)
					col = col+1
					if col >=  cols:
						col = 0
						row = row+1
			if empty:
				categoryContainer[0].get_parent().set_no_show_all(True)
				categoryContainer[0].get_parent().hide()
			else:
				categoryContainer[0].get_parent().set_no_show_all(False)
				categoryContainer[0].attach(gtk.Label(), cols+5, cols+6, 0, 1, gtk.EXPAND)
	
		# Search in long description
		if not foundPlugin and target == 0:
			self.FilterTable(widget, 1)
			return
		# Search in category
		elif not foundPlugin and target == 1:
			self.FilterTable(widget, 2)
			return

		self.TableAttached = True
		self.MainWin.show_all()

	def RebuildTable(self, widget, request):
		cols = (request.width - 60) / 220
		if cols == self.LastCols:
			return
		
		self.LastCols = cols
		if self.TableAttached:
			for categoryName, categoryContainer in self.TableCats.items():
				for pluginButton in categoryContainer[1]:
					categoryContainer[0].remove(pluginButton)
		
		for categoryName, categoryContainer in self.TableCats.items():
			col = 0
			row = 0
			for pluginButton in categoryContainer[1]:
				categoryContainer[0].attach(pluginButton, col, col+1, row, row+1, 0)
				col = col+1
				if col >= cols:
					col = 0
					row = row+1
			categoryContainer[0].attach(gtk.Label(), cols+5, cols+6, 0, 1, gtk.EXPAND)
		self.TableAttached = True
		self.MainWin.show_all()
		self.RightPane.get_child().props.vadjustment.value = self.RightVadj

	def SetMainWidgets(self, leftWidget, rightWidget):
		pane = self.LeftPane.get_child()
		if pane:
			pane.destroy()
		pane = self.RightPane.get_child()
		if (pane):
			pane.destroy()
		self.LeftPane.add(leftWidget)
		self.RightPane.add(rightWidget)
		self.MainWin.show_all()

	def CatSortCompare(self, v1, v2):
		if v1 == v2:
			return cmp(v1, v2)
		if v1 == _("General"):
			return cmp('', v2 or 'zzzzzzzz')
		if v2 == _("General"):
			return cmp(v1 or 'zzzzzzz', '')
		return cmp(v1 or 'zzzzzzzz', v2 or 'zzzzzzzz')

	def MakeImage(self, plugin = 0, category = 0, size = 32):
		img = gtk.Image()
		if plugin != 0:
			iconpath = "%s/plugin-%s.svg"%(PixmapDir, plugin.Name)
			if not os.path.exists(iconpath):
				iconpath = "%s/plugin-unknown.svg"%PixmapDir
			try:
				pixbuf = gtk.gdk.pixbuf_new_from_file_at_size(iconpath, size, size)
				img.set_from_pixbuf(pixbuf)
			except:
				img.set_from_stock(gtk.STOCK_MISSING_IMAGE, gtk.ICON_SIZE_BUTTON)
		elif category != 0:
			iconpath = "%s/category-%s.svg" % (PixmapDir, category)
			if not os.path.exists(iconpath):
				iconpath = "%s/category-uncategorized.svg" % PixmapDir
			try:
				pixbuf = gtk.gdk.pixbuf_new_from_file_at_size(iconpath, size, size)
				img.set_from_pixbuf(pixbuf)
			except:
				img.set_from_stock(gtk.STOCK_MISSING_IMAGE, gtk.ICON_SIZE_BUTTON)
		return img

	def ShowAboutDialog(self, widget):
		about = gtk.AboutDialog()
		about.set_name(_("CompizConfig Settings Manager"))
		about.set_version("0.1.0")
		about.set_comments(_("This is a settings manager for the CompizConfig configuration system."))
		about.set_copyright("Copyright \xC2\xA9 2007 Patrick Niklaus/Quinn Storm")
		about.set_translator_credits(_("translator-credits"))
		about.set_authors(["Patrick Niklaus <marex@opencompositing.org>", "Quinn Storm <quinn@beryl-project.org>"])
		about.set_artists(["Andrew Wedderburn <andrew.wedderburn@gmail.com>", "Patrick Niklaus <marex@opencompositing.org>", "Gnome Icon Theme Team"])
		about.set_icon(gdk.pixbuf_new_from_file(IconDir+"/apps/ccsm.svg"))
		about.set_logo(gdk.pixbuf_new_from_file(IconDir+"/apps/ccsm.svg"))
		about.set_website("http://www.opencompositing.org")
		about.show_all()
		about.run()
		about.destroy()

	def ShowPlugin(self, obj, select):
		self.RightVadj = self.RightPane.get_child().get_vadjustment().get_value()
		for name, value in self.PluginImages.items():
			widget = value.get_parent()
			if widget:
				widget.remove(value)
		pluginClass = PluginClass(select, self)
		self.ShowingPlugin = pluginClass
		self.SetMainWidgets(pluginClass.LeftWidget, pluginClass.RightWidget)
	
	def ShowAdvancedFilter(self, widget, run=0):
		if run == 0: # Well thats rather a hack but it works...
			self.TitleBuffer = self.MainWin.get_title()
			self.MainWin.set_title(self.TitleBuffer + " - Loading...")
			gobject.timeout_add(100, self.ShowAdvancedFilter, widget, 1)
			return

		self.RightVadj = self.RightPane.get_child().get_vadjustment().get_value()
		for name, value in self.PluginImages.items():
			widget = value.get_parent()
			if widget:
				widget.remove(value)
		filterPage = FilterPage(self, self.Context)
		self.SetMainWidgets(filterPage.LeftWidget, filterPage.RightWidget)
	
		self.MainWin.set_title(self.TitleBuffer)
		self.TitleBuffer = False

		return False
	
	def ShowProfileBackend(self, widget):
		self.RightVadj = self.RightPane.get_child().get_vadjustment().get_value()
		for name, value in self.PluginImages.items():
			widget = value.get_parent()
			if widget:
				widget.remove(value)
		profBackPage = ProfileBackendPage(self, self.Context)
		self.SetMainWidgets(profBackPage.LeftWidget, profBackPage.RightWidget)

	def UpdatePlugins(self):
		for category, container, plugins in self.TableCats.values():
				for i in range(len(plugins)):
					if plugins[i].Name != 'core':
						check = container[i].get_children()[0]
						self.BlockEnablePlugin += 1
						check.set_active(plugins[i].Enabled)
						self.BlockEnablePlugin -= 1
	
	def EnablePlugin(self, widget, plugin):
		if self.BlockEnablePlugin > 0:
			return 

		# attempt to resolve conflicts...
		conflicts = plugin.Enabled and plugin.DisableConflicts or plugin.EnableConflicts
		if HandlePluginConflicts(plugin, conflicts):
			plugin.Enabled = widget.get_active()
			self.UpdatePlugins()
		else:
			widget.set_active(plugin.Enabled)
		Write(plugin.Context)

	def ToggleCategory(self, widget, category):
		categoryContainer = self.TableCats[category]
		categoryY = categoryContainer[0].get_parent().get_allocation().y
		parentY = self.RightPane.get_child().get_allocation().y
		parentHeight = self.RightPane.get_child().get_allocation().height
		categoryBox = self.RightPane.get_child().get_child().get_child()
		boxHeight = categoryBox.get_allocation().height
		posY = categoryY - parentY
		neededHeight = posY + parentHeight
		if neededHeight > boxHeight:
			posY =  boxHeight - parentHeight
		self.RightPane.get_child().props.vadjustment.value = posY
	
	def ScreenChanged(self, widget):
		self.Context.Write()
		CurrentScreenNum = widget.get_active()
		self.Context.Read()

	def BackToMain(self, obj):
		global VisibleSettings
		VisibleSettings = []
		self.ResetMainWidgets()
		del self.ShowingPlugin
		# make sure its cleaned up here, since this is a nice safe place to do so
		self.ShowingPlugin = None
		
screens = getScreens()
CurrentScreenNum = gtk.gdk.display_get_default().get_default_screen().get_number()
context = ccs.Context(screens)
mainWin = MainWinClass(context).MainWin
mainWin.show_all()
gobject.timeout_add(2000, UpdateVisibleSettings, context)
gtk.main()
