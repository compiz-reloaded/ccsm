#!/usr/bin/env python

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
# Authors: Quinn Storm (quinn@beryl-project.org)
# Copyright (C) 2007 Quinn Storm



import ccs
import gtk
import gtk.gdk
import gobject
import os
import re
gdk = gtk.gdk
from xml.sax.saxutils import escape as EscapeMarkup

AllPlugins = []

#PixmapDir = "/usr/local/share/pixmaps"
PixmapDir = "./images"

def Write(ctx):
	ctx.Write()
	for plg in AllPlugins:
		if plg.Plugin.Name != 'core':
			plg.Enable.set_active(plg.Plugin.Enabled)

class Item:
	def __init__(self):
		pass

	def SetSelected(self,Selected):
		if (Selected):
			self.Label.set_markup("<b><i>%s</i></b>"%self.Name)
		else:
			self.Label.set_text(self.Name)

def CheckConflict(s,con,typ):
	if typ == 'Key':
		cval = s.Value[0]
	elif typ == 'Button':
		cval = s.Value[1]
	dlg = gtk.Dialog('Action Conflict',MainWin)
	dlg.vbox.pack_start(MakeLabel("The new value for the \"%s\" binding for the action \"%s\" in plugin \"%s\" conflicts with the action \"%s\" of the \"%s\" plugin.  Do you wish to clear \"%s\" in the \"%s\" plugin?  If you click No, the action will still be set."%(
		typ,s.ShortDesc,s.Plugin.ShortDesc,
		con.ShortDesc,con.Plugin.ShortDesc,
		con.ShortDesc,con.Plugin.ShortDesc,
		),400))
	dlg.add_button(gtk.STOCK_CANCEL,gtk.RESPONSE_CANCEL)
	dlg.add_button(gtk.STOCK_NO,gtk.RESPONSE_NO)
	dlg.add_button(gtk.STOCK_YES,gtk.RESPONSE_OK).grab_default()
	dlg.set_default_response(gtk.RESPONSE_OK)
	dlg.show_all()
	ret = dlg.run()
	dlg.destroy()
	return ret

def CheckActionConflicts(s,ks,bs,be,es):
	#first gather settings list
	allsettings = sum((sum((z.values() for z in p.Screens+[p.Display]),[]) for p in s.Plugin.Context.Plugins.values()),[])
	allsettings.remove(s)
	KCon=[]
	BCon=[]
	for se in allsettings:
		if se.Type == 'Action':
			if se.Value[0] == ks:
				KCon.append(se)
			if se.Value[1] == bs:
				BCon.append(se)
	if len(KCon) and ks and ks.lower() != 'disabled' and ks.lower() != 'none':
		for kc in KCon:
			ret = CheckConflict(s,kc,'Key')
			if ret == gtk.RESPONSE_OK:
				v = kc.Value
				kc.Value = ['None',v[1],v[2],v[3]]
			if ret == gtk.RESPONSE_CANCEL:
				return False
	if len(BCon) and bs and bs.lower() != 'disabled' and bs.lower() != 'none':
		for bc in BCon:
			ret = CheckConflict(s,bc,'Button')
			if ret == gtk.RESPONSE_OK:
				v = bc.Value
				bc.Value = [v[0],'None',v[2],v[3]]
			if ret == gtk.RESPONSE_CANCEL:
				return False
	return True

class PureVirtualError(Exception):
	pass

TDef = gtk.FILL | gtk.EXPAND
TXp = 4
TYp = 2

class SettingItem:
	def __init__(self,Setting):
		self.Custom = False
		self.Setting = Setting
		self.Blocked = 0
		self.MakeLabel()
		self.Reset = gtk.Button()
		self.Reset.set_image(gtk.image_new_from_stock(
			gtk.STOCK_CLEAR,gtk.ICON_SIZE_BUTTON))
		self.Reset.connect('clicked',self.DoReset)
		self._Init()

	def Attach(self,Table,row):
		if self.Custom:
			Table.attach(self.Widget,0,100,row,row+1,TDef,TDef,TXp,TYp)
		else:
			Table.attach(self.Label,0,1,row,row+1,gtk.FILL,TDef,TXp,TYp)
			Table.attach(self.Widget,1,99,row,row+1,TDef,TDef,TXp,TYp)
			Table.attach(self.Reset,99,100,row,row+1,0,TDef,TXp,TYp)

	def PureVirtual(self,str):
		raise PureVirtualError,str,self.Setting.Name

	def _Init(self):
		self.PureVirtual('_Init')
	
	def DoReset(self,foo):
		self.Setting.Reset()
		Write(self.Setting.Plugin.Context)
		self.Read()

	def MakeLabel(self):
		self.Label = gtk.Label(self.Setting.ShortDesc)
		self.Label.props.xalign=0
		self.Label.props.wrap_mode = gtk.WRAP_WORD
		self.Label.set_size_request(160,-1)
		self.Label.set_line_wrap(True)

	def Block(self):
		self.Blocked = self.Blocked + 1
	
	def UnBlock(self):
		self.Blocked = self.Blocked - 1

	def Read(self):
		self.Block()
		self._Read()
		self.UnBlock()

	def _Read(self):
		self.PureVirtual('_Read')

	def Changed(self, *args, **kwargs):
		if self.Blocked <= 0:
			self._Changed()
			Write(self.Setting.Plugin.Context)

	def _Changed(self):
		self.PureVirtual('_Changed')

class StringMatchSetting(SettingItem):
	def _Init(self):
		self.Widget = gtk.Entry()
		self.Widget.connect('changed',self.Changed)
	def _Read(self):
		self.Widget.set_text(self.Setting.Value)
	def _Changed(self):
		self.Setting.Value = self.Widget.get_text()
class StringChoiceSetting(SettingItem):
	def _Init(self):
		self.Widget = gtk.combo_box_new_text()
		for Text in self.Setting.Info:
			self.Widget.append_text(Text)
		self.Widget.connect('changed',self.Changed)
	def _Read(self):
		indx=0
		for n in self.Setting.Info:
			if self.Setting.Value == n:
				break
			indx=indx+1
		self.Widget.set_active(indx)
	def _Changed(self):
		self.Setting.Value = self.Widget.get_active_text()

class BoolSetting(SettingItem):
	def _Init(self):
		self.Custom = True
		self.Widget = gtk.HBox()
		self.CheckButton = gtk.CheckButton(self.Setting.ShortDesc)
		self.Widget.pack_start(self.CheckButton,True,True)
		self.Widget.pack_start(self.Reset,False,False)
		self.CheckButton.connect('toggled',self.Changed)
	def _Read(self):
		self.CheckButton.set_active(self.Setting.Value)
	def _Changed(self):
		self.Setting.Value = self.CheckButton.get_active()

class IntFloatSetting(SettingItem):
	def _Init(self):
		self.Widget = gtk.HBox()
		if self.Setting.Type == 'Int':
			inc = 1
		else:
			inc = self.Setting.Info[2]
		self.Adj = gtk.Adjustment(self.Setting.Value,
				self.Setting.Info[0],self.Setting.Info[1],
				inc,inc*10)
		self.Spin = gtk.SpinButton(self.Adj)
		if self.Setting.Type == 'Float':
			self.Spin.set_digits(4)
		self.Scale = gtk.HScale(self.Adj)
		self.Scale.props.draw_value = False
		#self.Widget.pack_start(self.Scale,True,True)
		#self.Widget.pack_start(self.Spin,False,False)
		self.Adj.connect('value-changed',self.Changed)
	def Attach(self,Table,row):
		Table.attach(self.Label,0,1,row,row+1,gtk.FILL,TDef,TXp,TYp)
		Table.attach(self.Scale,1,2,row,row+1,TDef,TDef,TXp,TYp)
		Table.attach(self.Spin,2,3,row,row+1,gtk.FILL,TDef,TXp,TYp)
		Table.attach(self.Reset,99,100,row,row+1,0,TDef,TXp,TYp)
	def _Read(self):
		self.Adj.set_value(self.Setting.Value)
	def _Changed(self):
		self.Setting.Value = self.Adj.get_value()

class ColorSetting(SettingItem):
	def _Init(self):
		self.Widget = gtk.ColorButton()
		self.Widget.set_use_alpha(True)
		self.Widget.connect('color-set',self.Changed)
	def _Read(self):
		col = gdk.Color()
		col.red=self.Setting.Value[0]
		col.green=self.Setting.Value[1]
		col.blue=self.Setting.Value[2]
		self.Widget.set_color(col)
		self.Widget.set_alpha(self.Setting.Value[3])
	def _Changed(self):
		col = self.Widget.get_color()
		alpha = self.Widget.get_alpha()
		self.Setting.Value = [col.red,col.green,col.blue,alpha]

class ListChoiceSetting(SettingItem):
	def _Init(self):
		self.Widget = gtk.Frame(self.Setting.ShortDesc)
		self.Table = gtk.Table()
		self.Custom = True
		row = 0
		col = 0
		self.Checks=[]
		for val in self.Setting.Info[1]:
			cbx = gtk.CheckButton(val)
			self.Checks.append((val,cbx))
			self.Table.attach(cbx,col,col+1,row,row+1,TDef,TDef,TXp,TYp)
			cbx.connect('toggled',self.Changed)
			col = col + 1
			if (col>=3):
				col = 0
				row = row + 1
		self.HBox = gtk.HBox()
		self.VBox = gtk.VBox()
		self.HBox.pack_start(self.VBox,False,False)
		self.HBox.pack_start(self.Table,True,True)
		self.VBox.pack_start(self.Reset,False,False)
		self.Widget.add(self.HBox)
	def _Read(self):
		for cv,c in self.Checks:
			c.set_active(False)
		for v in self.Setting.Value:
			for cv,c in self.Checks:
				if cv == v:
					c.set_active(True)
	def _Changed(self):
		v = []
		for cv,c in self.Checks:
			if c.get_active():
				v = v + [cv]
		self.Setting.Value = v
	
	def Attach(self,Table,row):
		Table.attach(self.Widget,0,100,row,row+1,xpadding=5)

class ListSetting(SettingItem):
	def _Init(self):
		self.Widget = gtk.Frame(self.Setting.ShortDesc)
		self.Custom = True
		Info = self._ListInfo()
		self.Store = gtk.ListStore(*Info[0])
		self.View = gtk.TreeView(self.Store)
		if len(Info[0]) == 1:
			self.View.set_headers_visible(False)
		self.Select = self.View.get_selection()
		self.Select.set_mode(gtk.SELECTION_MULTIPLE)
		for I in Info[1]:
			self.View.insert_column_with_attributes(-1,I[1],I[0],**I[2])
		self.Store.connect('row-changed',self.Changed)
		self.Store.connect('row-deleted',self.Changed)
		self.Store.connect('row-inserted',self.Changed)
		self.Store.connect('rows-reordered',self.Changed)
		VBox = gtk.VBox()
		self.Widget.add(VBox)
		self.Scroll = gtk.ScrolledWindow()
		self.Scroll.props.hscrollbar_policy = gtk.POLICY_NEVER
		self.Scroll.props.hscrollbar_policy = gtk.POLICY_AUTOMATIC
		self.Scroll.add(self.View)
		VBox.pack_start(self.Scroll,True,True)
		HBox = gtk.HBox(False)
		VBox.pack_start(HBox,False,False)
		for bt in (
				(gtk.STOCK_ADD,self.Add),
				(gtk.STOCK_DELETE,self.Delete),
				(gtk.STOCK_EDIT,self.Edit),
				(gtk.STOCK_GO_UP,self.MoveUp),
				(gtk.STOCK_GO_DOWN,self.MoveDown),
				):
			b=gtk.Button(bt[0])
			b.set_use_stock(True)
			HBox.pack_start(b)
			b.connect('clicked',bt[1])
		HBox.pack_start(self.Reset)
	def Add(self,b):
		val = self._Edit()
		if val is not None:
			self.Block()
			Iter = self.Store.append()
			self.UnBlock()
			self._ListSet(Iter,val)
	def Delete(self,b):
		sel = self.Select.get_selected_rows()[1]
		for path in sel:
			Iter = self.Store.get_iter(path)
			self.Store.remove(Iter)
	def Edit(self,b):
		sel = self.Select.get_selected_rows()[1]
		if len(sel) == 1:
			Iter = self.Store.get_iter(sel[0])
			val = self._Edit(self._ListGet(Iter))
			if val is not None:
				self._ListSet(Iter,val)
	def MoveUp(self,b):
		sel = self.Select.get_selected_rows()[1]
		if len(sel) == 1:
			Iter = self.Store.get_iter(sel[0])
			Prev = self.Store.get_iter_first()
			if not self.Store.get_path(Prev) == self.Store.get_path(Iter):
				while Prev is not None and not self.Store.get_path(
						self.Store.iter_next(Prev)) == self.Store.get_path(Iter):
					Prev = self.Store.iter_next(Prev)
				self.Store.swap(Iter,Prev)
	def MoveDown(self,b):
		sel = self.Select.get_selected_rows()[1]
		if len(sel) == 1:
			Iter = self.Store.get_iter(sel[0])
			Next = self.Store.iter_next(Iter)
			if Next is not None:
				self.Store.swap(Iter,Next)
	def _ListInfo(self):
		self.PureVirtual('_ListInfo')
	def _Read(self):
		self.Store.clear()
		for v in self.Setting.Value:
			Iter=self.Store.append()
			self._ListSet(Iter,v)
	def _ListSet(self,Iter,v):
		self.PureVirtual('_ListRead')
	def _ListGet(self,Iter):
		self.PureVirtual('_ListGet')
	def _Edit(self,d,v=None):
		self.PureVirtual('_Edit')
	def _Changed(self):
		val=[]
		Iter=self.Store.get_iter_first()
		while Iter:
			val.append(self._ListGet(Iter))
			Iter = self.Store.iter_next(Iter)
		self.Setting.Value = val
	def Attach(self,Table,row):
		Table.attach(self.Widget,0,100,row,row+1,xpadding=5)

class StringMatchListSetting(ListSetting):
	def _ListInfo(self):
		return (gobject.TYPE_STRING,),[(gtk.CellRendererText(),
			"Value (%s)" % self.Setting.Info[0],{'text':0})]
	def _ListSet(self,Iter,v):
		self.Store.set(Iter,0,v)
	def _ListGet(self,Iter):
		return self.Store.get(Iter,0)[0]
	def _Edit(self,v=None):
		d = gtk.Dialog("Edit %s"%self.Setting.ShortDesc,MainWin)
		d.add_button(gtk.STOCK_CANCEL,gtk.RESPONSE_CANCEL)
		d.add_button(gtk.STOCK_OK,gtk.RESPONSE_OK).grab_default()
		d.set_default_response(gtk.RESPONSE_OK)
		d.vbox.pack_start(gtk.Label("Value(%s) for %s:"%(self.Setting.Info[0],self.Setting.ShortDesc)))
		e = gtk.Entry()
		e.props.activates_default=True
		if v is not None:
			e.set_text(v)
		d.vbox.pack_start(e)
		d.vbox.show_all()
		r = d.run()
		d.destroy()
		if r == gtk.RESPONSE_OK:
			return e.get_text()
		return None

class IntFloatListSetting(ListSetting):
	def _ListInfo(self):
		return (gobject.TYPE_STRING,),[(gtk.CellRendererText(),
			"Value (%s)" % self.Setting.Info[0],{'text':0})]
	def _ListSet(self,Iter,v):
		self.Store.set(Iter,0,str(v))
	def _ListGet(self,Iter):
		return eval(self.Store.get(Iter,0)[0])
	def _Edit(self,v=None):
		d = gtk.Dialog("Edit %s"%self.Setting.ShortDesc,MainWin)
		d.add_button(gtk.STOCK_CANCEL,gtk.RESPONSE_CANCEL)
		d.add_button(gtk.STOCK_OK,gtk.RESPONSE_OK).grab_default()
		d.set_default_response(gtk.RESPONSE_OK)
		d.vbox.pack_start(gtk.Label("Value(%s) for %s:"%(self.Setting.Info[0],self.Setting.ShortDesc)))
		h = gtk.HBox()
		d.vbox.pack_start(h)
		if self.Setting.Info[0] == 'Int':
			inc = 1
		else:
			inc = self.Setting.Info[1][2]
		val = self.Setting.Info[1][0]
		if v is not None:
			val = v
		adj = gtk.Adjustment(val,
				self.Setting.Info[1][0],self.Setting.Info[1][1],
				inc,inc*10)
		spin = gtk.SpinButton(adj)
		if self.Setting.Info[0] == 'Float':
			spin.set_digits(4)
		scale = gtk.HScale(adj)
		scale.props.draw_value = False
		h.pack_start(scale,True,True)
		h.pack_start(spin,False,False)
		d.vbox.show_all()
		r = d.run()
		d.destroy()
		if r == gtk.RESPONSE_OK:
			return e.get_text()
		return None

def MakeSetting(Setting):
	if Setting.Type == 'String' and len(Setting.Info):
		return StringChoiceSetting(Setting)
	elif Setting.Type == 'String' or Setting.Type == 'Match':
		return StringMatchSetting(Setting)
	elif Setting.Type == 'Bool':
		return BoolSetting(Setting)
	elif Setting.Type == 'Float' or Setting.Type == 'Int':
		return IntFloatSetting(Setting)
	elif Setting.Type == 'Color':
		return ColorSetting(Setting)
	elif Setting.Type == 'List':
		if Setting.Info[0] == 'String' and len(Setting.Info[1]):
			return ListChoiceSetting(Setting)
		elif Setting.Info[0] == 'String' or Setting.Info[0] == 'Match':
			return StringMatchListSetting(Setting)
		elif Setting.Info[0] == 'Int' or Setting.Info[0] == 'Float':
			return IntFloatListSetting(Setting)
		else:
			raise TypeError, "Unhandled list type %s for %s"%(Setting.Info[0],Setting.Name)
	return None

def SettingSortCompare(v1,v2):
	if v1.Type != v2.Type:
		return cmp(v1.Type,v2.Type)
	else:
		return cmp(v1.ShortDesc,v2.ShortDesc)

class SubGroupArea:
	def __init__(self,Name,SubGroup):
		if Name == '':
			self.Widget = gtk.Table()
			self.Child = self.Widget
		else:
			self.Widget = gtk.Frame()
			self.Expander = gtk.Expander(Name)
			self.Widget.add(self.Expander)
			self.Expander.set_expanded(False)
			self.Child = gtk.Table()
			self.Expander.add(self.Child)
		self.Empty = True
		row = 0
		for Set in sorted(sum((v.values() for v in [SubGroup.Display]+SubGroup.Screens),[]),SettingSortCompare):
			if not Set.Name == '____plugin_enabled':
				sit = MakeSetting(Set)
				if sit is not None:
					sit.Read()
					sit.Attach(self.Child,row)
					row=row+1
					self.Empty = False
		if Name != '' and row < 4: # ahi hay magic numbers!
			self.Expander.set_expanded(True)

class Page(object):
	def __init__(self,Name):
		self.Widget = gtk.VBox()
		self.SetContainer = gtk.VBox()
		Scroll = gtk.ScrolledWindow()
		Scroll.props.hscrollbar_policy = gtk.POLICY_NEVER
		Scroll.props.vscrollbar_policy = gtk.POLICY_AUTOMATIC
		View = gtk.Viewport()
		View.set_border_width(5)
		View.set_shadow_type(gtk.SHADOW_NONE)
		self.Widget.pack_start(Scroll,True,True)
		Scroll.add(View)
		View.add(self.SetContainer)
		self.Empty = True

class GroupPage(Page):
	def __init__(self,Name,Group):
		super(GroupPage, self).__init__(Name)

		if (Group.has_key('')):
			sga = SubGroupArea('',Group[''])
			if not sga.Empty:
				self.SetContainer.pack_start(sga.Widget,False,False)
				self.Empty = False
		for SubGroup in Group:
			if not SubGroup == '':
				sga = SubGroupArea(SubGroup,Group[SubGroup])
				if not sga.Empty:
					self.SetContainer.pack_start(sga.Widget,False,False)
					self.Empty = False

def HandlePluginConflicts(conf):
	if len(conf) == 0:
		return True
	dlg = gtk.Dialog('Plugin Conflict',MainWin)
	dlg.add_button(gtk.STOCK_CANCEL,gtk.RESPONSE_CANCEL)
	dlg.add_button(gtk.STOCK_OK,gtk.RESPONSE_OK).grab_default()
	dlg.set_default_response(gtk.RESPONSE_OK)
	for c in conf:
		if c[0] == 'SameFeature':
			#see if we can deactivate the plugin
			#mentioned in c[2]
			dlg.vbox.pack_start(MakeLabel(
				"Plugin \"%s\" provides feature \"%s\" which is also provided by the plugin you are trying to enable.  Click OK to disable plugin \"%s\", or Cancel to stop trying to enable this plugin"%(c[2][0].ShortDesc,c[1],c[2][0].ShortDesc),400))
			dlg.show_all()
			ret = dlg.run()
			dlg.destroy()
			if ret == gtk.RESPONSE_OK:
				dcon = c[2][0].DisableConflicts
				if HandlePluginConflicts(dcon):
					c[2][0].Enabled = False
				else:
					return False
			else:
				return False
		elif c[0] == 'RequiresFeature':
			#we need to activate one of c[2]
			dlg.vbox.pack_start(MakeLabel(
				"The plugin you are trying to enable requires feature \"%s\" which is provided by the following plugins.  Click OK to enable the selected plugin or Cancel to stop trying to enable this plugin"%c[1],400),False,False)
			cmb = gtk.combo_box_new_text()
			dlg.vbox.pack_start(cmb,False,False)
			for p in c[2]:
				cmb.append_text(p.ShortDesc)
			cmb.set_active_text(c[2][0].ShortDesc)
			dlg.show_all()
			ret = dlg.run()
			rval = cmb.get_active_text()
			dlg.destroy()
			if ret == gtk.RESPONSE_OK:
				for p in c[2]:
					if p.ShortDesc == rval:
						econ = p.EnableConflicts
						if HandlePluginConflicts(econ):
							p.Enabled = True
						else:
							return False
						break
			else:
				return False
		elif c[0] == 'RequiresPlugin':
			dlg.vbox.pack_start(MakeLabel(
				"The plugin you are trying to enable requires the plugin \"%s\". Click OK to enable \"%s\" or Cancel to stop trying to enable this plugin"%(c[2][0].ShortDesc,c[2][0].ShortDesc),400))
			dlg.show_all()
			ret = dlg.run()
			dlg.destroy()
			if ret == gtk.RESPONSE_OK:			
				econ = c[2][0].EnableConflicts
				if HandlePluginConflicts(econ):
					c[2][0].Enabled = True
				else:
					return False
			else:
				return False
		elif c[0] == 'FeatureNeeded':
			plist = ', '.join("\"%s\""%p.ShortDesc for p in c[2])
			dlg.vbox.pack_start(MakeLabel(
				"The plugin you are trying to disable provides the feature \"%s\" which is required by the plugins %s. Click OK to disable these plugins or Cancel to stop trying to disable this plugin"%(c[1],plist),400))
			dlg.show_all()
			ret = dlg.run()
			dlg.destroy()
			if ret == gtk.RESPONSE_OK:
				for p in c[2]:
					dcon = p.DisableConflicts
					if HandlePluginConflicts(dcon):
						p.Enabled = False
					else:
						return False
			else:
				return False
		elif c[0] == 'PluginNeeded':
			plist = ', '.join("\"%s\""%p.ShortDesc for p in c[2])
			dlg.vbox.pack_start(MakeLabel(
				"The plugin you are trying to disable is required by the plugins %s. Click OK to disable these plugins or Cancel to stop trying to disable this plugin"%(plist),400))
			dlg.show_all()
			ret = dlg.run()
			dlg.destroy()
			if ret == gtk.RESPONSE_OK:
				for p in c[2]:
					dcon = p.DisableConflicts
					if HandlePluginConflicts(dcon):
						p.Enabled = False
					else:
						return False
			else:
				return False

	return True

class ActionItem(SettingItem):
	pass

class ActionPage:
	def __init__(self,Plugin,Context=None):
		self.EdgeList = ['None','TopLeft','Top','TopRight','Left','Right','BottomLeft','Bottom','BottomRight']
		self.Widget = gtk.VBox()
		self.Plugin = Plugin
		self.Context = Context
		self.Search = gtk.Entry()
		self.Widget.pack_start(self.Search,False,False)
		self.Scroll = gtk.ScrolledWindow()
		self.Scroll.props.hscrollbar_policy = gtk.POLICY_AUTOMATIC
		self.Scroll.props.vscrollbar_policy = gtk.POLICY_AUTOMATIC
		self.Store = gtk.TreeStore(
				gobject.TYPE_STRING,	#0 - Name
				gobject.TYPE_UINT,		#1 - Key
				gobject.TYPE_UINT,		#2 - KeyMods
				gobject.TYPE_STRING,	#3 - Button
				gobject.TYPE_STRING,	#4 - Edges
				gobject.TYPE_BOOLEAN,	#5 - Visible/Editable
				gobject.TYPE_BOOLEAN,	#6 - Bell
				gobject.TYPE_BOOLEAN,   #7 - KeyPossible
				gobject.TYPE_BOOLEAN,   #8 - ButPossible
				gobject.TYPE_BOOLEAN,   #9 - EdgePossible
				gobject.TYPE_BOOLEAN,   #10 - BellPossible
				gobject.TYPE_STRING,	#11 - group
				gobject.TYPE_STRING,	#12 - subgroup
				gobject.TYPE_STRING,	#13 - setting
				gobject.TYPE_STRING,	#14 - plugin
				gobject.TYPE_STRING,	#15 - disp/scn str XXX
				)
		self.ComboStore = gtk.ListStore(gobject.TYPE_STRING)
		for edge in self.EdgeList:
			iter = self.ComboStore.append()
			self.ComboStore.set(iter,0,edge)
		self.TreeView = gtk.TreeView(self.Store)
		self.TreeView.set_headers_visible(True)
		self.TreeView.insert_column_with_attributes(-1,'Name',gtk.CellRendererText(),text=0)
		AR = gtk.CellRendererAccel()
		AR.connect('accel-edited',self.KeyEdited)
		AR.connect('accel-cleared',self.KeyCleared)
		self.TreeView.insert_column_with_attributes(-1,'Key',AR,accel_key=1,accel_mods=2,editable=7,visible=5,sensitive=7)
		BR = gtk.CellRendererText()
		BR.connect('edited',self.ButtonEdited)
		self.TreeView.insert_column_with_attributes(-1,'Button',BR,text=3,editable=8,visible=5,sensitive=8)
		ECOM = gtk.CellRendererCombo()
		ECOM.props.has_entry = False
		ECOM.props.model = self.ComboStore
		ECOM.props.text_column = 0
		ECOM.connect('edited',self.EdgeEdited)
		self.TreeView.insert_column_with_attributes(-1,'Screen Edge',ECOM,text=4,editable=9,visible=5,sensitive=9)
		BELR = gtk.CellRendererToggle()
		BELR.props.xalign=0
		BELR.connect('toggled',self.BellEdited)
		self.TreeView.insert_column_with_attributes(-1,'On System Bell',BELR,activatable=10,visible=5,sensitive=10,active=6) # may replace with one setting in general
		for c in self.TreeView.get_columns():
			c.set_resizable(True)
		self.Scroll.add(self.TreeView)
		self.Widget.pack_start(self.Scroll,True,True)
		self.Empty = True
		self.TreeView.connect('row-activated',self.Activated)
		self.Plugins={}
		if Plugin:
			self.DoGroups(Plugin.Groups,None,Plugin.Name)
		else:
			for p in Context.Plugins.values():
				pgiter=self.Store.append(None)
				self.Store.set(pgiter,0,p.ShortDesc,5,False,7,False,8,False,9,False,10,False)
				if not self.DoGroups(p.Groups,pgiter,p.Name):
					self.Store.remove(pgiter)
	def DoGroups(self,GroupList,Iter,PlugName):
		self.Plugins[PlugName]={}
		pempty = True
		for g,gi in GroupList.items():
			gempty = True
			giter = self.Store.append(Iter)
			self.Store.set(giter,0,g == '' and 'General' or g,5,False,7,False,8,False,9,False,10,False)
			self.Plugins[PlugName][g] = {}
			for sg,sgi in gi.items():
				if sg != '':
					sgiter = self.Store.append(giter)
					self.Store.set(sgiter,0,sg,5,False,7,False,8,False,9,False,10,False)
				self.Plugins[PlugName][g][sg]={}
				sgempty=True
				for s in sum((v.values() for v in [sgi.Display]+sgi.Screens),[]):
					if s.Type == 'Action':
						if sg != '':
							i = self.Store.append(sgiter)
						else:
							i = self.Store.append(giter)
						key,mods = gtk.accelerator_parse(s.Value[0])
						self.Store.set(i,0,s.ShortDesc,1,key,2,mods,3,s.Value[1],4,s.Value[3] or 'None',5,True,6,s.Value[2],
								7,s.Info[0],8,s.Info[1],9,s.Info[3],10,s.Info[2],11,g,12,sg,13,s.Name,14,PlugName)
						self.Plugins[PlugName][g][sg][s.Name]=s
						gempty = False
						sgempty = False
						pempty = False
						self.Empty = False
				if sgempty:

					if sg != '':
						self.Store.remove(sgiter)
			if gempty:
				self.Store.remove(giter)
		return not pempty
	def Activated(self,obj,path,col):
		def ResetButton(obj,s,iter):
			if s.Info[0]:
				KE.set_text(s.DefaultValue[0])
			if s.Info[1]:
				BE.set_text(s.DefaultValue[1])
			if s.Info[2]:
				BELV.set_active(s.DefaultValue[2])
			if s.Info[3]:
				ev=0
				for p in self.EdgeList:
					if p == s.DefaultValue[3]:
						EC.set_active(ev)
					ev = ev + 1
		iter = self.Store.get_iter(path)
		g,sg,sn,pn,kv,km,bs,es,be = self.Store.get(iter,11,12,13,14,1,2,3,4,6)
		if sg is None or g is None or sn is None:
			if self.TreeView.row_expanded(path):
				self.TreeView.collapse_row(path)
			else:
				self.TreeView.expand_row(path,False)
			return
		s = self.Plugins[pn][g][sg][sn]
		Dlg = gtk.Dialog("Edit Action: %s"%s.ShortDesc,MainWin)
		Dlg.add_button(gtk.STOCK_CANCEL,gtk.RESPONSE_CANCEL)
		Dlg.add_button(gtk.STOCK_OK,gtk.RESPONSE_OK).grab_default()
		Dlg.set_default_response(gtk.RESPONSE_OK)
		TB = gtk.Table()
		Dlg.vbox.pack_start(TB,False,False)
		if s.Info[0]:
			KE = gtk.Entry()
			KE.set_text(gtk.accelerator_name(kv,km) or 'None')
			KL = gtk.Label('Key')
			KL.props.xalign=0
			TB.attach(KL,0,1,0,1,TDef,TDef,TXp,TYp)
			TB.attach(KE,1,2,0,1,TDef,TDef,TXp,TYp)
		if s.Info[1]:
			BE = gtk.Entry()
			BE.set_text(bs)
			BL = gtk.Label('Button')
			BL.props.xalign=0
			TB.attach(BL,0,1,1,2,TDef,TDef,TXp,TYp)
			TB.attach(BE,1,2,1,2,TDef,TDef,TXp,TYp)
		if s.Info[3]:
			EC = gtk.ComboBox(self.ComboStore)
			edv = 0
			for edg in self.EdgeList:
				if edg == es:
					break
				edv = edv + 1
			EC.set_active(edv)
			ER = gtk.CellRendererText()
			EC.pack_start(ER)
			EC.add_attribute(ER,'text',0)
			EL = gtk.Label('Screen Edge')
			EL.props.xalign=0
			TB.attach(EL,0,1,2,3,TDef,TDef,TXp,TYp)
			TB.attach(EC,1,2,2,3,TDef,TDef,TXp,TYp)
		if s.Info[2]:
			BEL = gtk.CheckButton('On System Bell')
			BEL.set_active(be)
			TB.attach(BEL,0,2,3,4,TDef,TDef,TXp,TYp)
		hb = gtk.HBox()
		hb.pack_start(MakeLabel('Reset To Defaults'),True,True)
		rb = gtk.Button()
		ri = gtk.Image()
		ri.set_from_stock(gtk.STOCK_CLEAR,gtk.ICON_SIZE_BUTTON)
		rb.set_image(ri)
		hb.pack_end(rb)
		rb.connect('clicked',ResetButton,s,iter)
		TB.attach(hb,0,2,4,5,TDef,TDef,TXp,TYp)
		Dlg.show_all()
		resp = Dlg.run()
		if s.Info[0]:
			KV = KE.get_text()
		if s.Info[1]:
			BV = BE.get_text()
		if s.Info[2]:
			BELV = BEL.get_active()
		if s.Info[3]:
			EV = EC.get_active()
		Dlg.destroy()
		if resp == gtk.RESPONSE_OK:
			if s.Info[0]:
				akey,amods=gtk.accelerator_parse(KV)
				self.Store.set(iter,1,akey,2,amods)
			if s.Info[1]:
				self.Store.set(iter,3,BV)
			if s.Info[2]:
				self.Store.set(iter,6,BELV)
			if s.Info[3]:
				self.Store.set(iter,4,self.EdgeList[EV])
			self.WriteSetting(iter)
	def WriteSetting(self,iter):
		g,sg,sn,pn,kv,km,bs,es,be = self.Store.get(iter,11,12,13,14,1,2,3,4,6)
		s = self.Plugins[pn][g][sg][sn]
		ks = gtk.accelerator_name(kv,km)
		if CheckActionConflicts(s,ks,bs,be,es):
			s.Value = [ks,bs,be,es]
			Write(s.Plugin.Context)
		ks,bs,be,es = s.Value
		kv,km = gtk.accelerator_parse(ks)
		self.Store.set(iter,1,kv,2,km,3,bs,4,es,6,be)
	def KeyEdited(self,obj,path,key,mods,code):
		iter = self.Store.get_iter_from_string(path)
		self.Store.set(iter,1,key,2,mods)
		self.WriteSetting(iter)
	def KeyCleared(self,obj,path):
		iter = self.Store.get_iter_from_string(path)
		self.Store.set(iter,1,0,2,0)
		self.WriteSetting(iter)
	def ButtonEdited(self,obj,path,val):
		iter = self.Store.get_iter_from_string(path)
		self.Store.set(iter,3,val)
		self.WriteSetting(iter)
	def EdgeEdited(self,obj,path,val):
		iter = self.Store.get_iter_from_string(path)
		self.Store.set(iter,4,val)
		self.WriteSetting(iter)
	def BellEdited(self,obj,path):
		iter = self.Store.get_iter_from_string(path)
		val = self.Store.get(iter,6)[0]
		if val:
			val = False
		else:
			val = True
		self.Store.set(iter,6,val)
		self.WriteSetting(iter)


def MakeLabel(Val=None,wrap=160):
	if Val is not None:
		L = gtk.Label(Val)
	else:
		L = gtk.Label()
	L.props.xalign=0
	L.props.wrap_mode = gtk.WRAP_WORD
	L.set_line_wrap(True)
	L.set_size_request(wrap,-1)
	return L

class PluginClass:
	def __init__(self,Plugin,Main):
		self.Plugin = Plugin
		self.LeftWidget = gtk.VBox(False,10)
		self.LeftWidget.set_border_width(15)
		self.PlugLabel = MakeLabel()
		self.PlugLabel.set_markup("<span color='%s' size='large' weight='800'>%s</span>"%(Main.BrightColor,Plugin.ShortDesc))
		self.PlugImg = Main.MakeImage(Plugin,size=64)
		self.LeftWidget.pack_start(self.PlugImg,False,False)
		self.LeftWidget.pack_start(self.PlugLabel,False,False)
		self.InfoLabelCont = gtk.HBox()
		self.InfoLabelCont.set_border_width(10)
		self.LeftWidget.pack_start(self.InfoLabelCont,False,False)
		self.InfoLabel = MakeLabel(Plugin.LongDesc)
		self.InfoLabelCont.pack_start(self.InfoLabel,True,True)
		if Plugin.Name != 'core':
			self.EnLabel = MakeLabel()
			self.EnLabel.set_markup("<span color='%s' size='large' weight='800'>%s</span>"%(Main.BrightColor,'Use This Plugin'))
			self.LeftWidget.pack_start(self.EnLabel,False,False)
			self.EnCheckCont = gtk.HBox()
			self.EnCheckCont.set_border_width(10)
			self.LeftWidget.pack_start(self.EnCheckCont,False,False)
			self.EnCheck = gtk.CheckButton()
			self.EnCheck.add(MakeLabel("Enable %s"%Plugin.ShortDesc,120))
			self.EnCheck.set_active(Plugin.Enabled)
			self.EnCheckCont.pack_start(self.EnCheck,True,True)
			self.EnCheck.connect('toggled',self.EnChange)
		self.BackButton = gtk.Button(gtk.STOCK_GO_BACK)
		self.BackButton.set_use_stock(True)
		self.LeftWidget.pack_end(self.BackButton,False,False)
		self.BackButton.connect('clicked',Main.BackToMain)
		self.RightWidget = gtk.Notebook()
		for name,group in Plugin.Groups.items():
			name = name or 'General'
			gp = GroupPage(name,group)
			if not gp.Empty:
				self.RightWidget.append_page(gp.Widget,gtk.Label(name))
		ap = ActionPage(Plugin)
		if not ap.Empty:
			self.RightWidget.append_page(ap.Widget,gtk.Label('Actions'))
		self.Block = 0
	def EnChange(self,wid):
		if self.Block>0:
			return
		self.Block = self.Block + 1
		#attempt to resolve conflicts...
		conf = self.Plugin.Enabled and self.Plugin.DisableConflicts or (
				self.Plugin.EnableConflicts)
		if HandlePluginConflicts(conf):
			self.Plugin.Enabled = wid.get_active()
		else:
			wid.set_active(self.Plugin.Enabled)
		Write(self.Plugin.Context)
		self.Block = self.Block - 1

def Quit(foo):
	gtk.main_quit()

class MainWinClass:
	def __init__(self,Context):
		self.Context = Context
		self.MainWin = gtk.Window()
		self.MainWin.connect("destroy",Quit)
		self.MainWin.set_default_size(940,520)
		self.MainWin.set_title("CCS Manager")
		#set up the Entry to get the BrightColor
		StyleWidget = gtk.Entry()
		self.MainWin.add(StyleWidget)
		StyleWidget.realize()
		bc = StyleWidget.style.bg[gtk.STATE_SELECTED]
		self.BrightColor = "#%.4x%.4x%.4x"%(bc.red,bc.green,bc.blue)
		self.MainWin.remove(StyleWidget)
		StyleWidget.destroy()
		#build the panes
		self.MainBox = gtk.HBox()
		self.MainWin.add(self.MainBox)
		self.LeftPane = gtk.Alignment()
		self.LeftPane.set_size_request(200,400)
		self.RightPane = gtk.Alignment()
		self.RightPane.set_border_width(5)
		self.RightPane.props.yscale=1
		self.RightPane.props.xscale=1
		self.RightPane.props.xalign=0
		self.RightPane.props.yalign=0
		self.LeftPane.props.yscale=1
		self.LeftPane.props.xscale=1
		self.LeftPane.props.xalign=0
		self.LeftPane.props.yalign=0
		self.MainBox.pack_start(self.LeftPane,False,False)
		self.MainBox.pack_start(self.RightPane,True,True)
		self.Categories={}
		self.PluginImages={}
		for pn,po in self.Context.Plugins.items():
			self.PluginImages[pn]=self.MakeImage(po)
		for c in sorted(self.Context.Categories,self.CatSortCompare):
			self.Categories[c]=[]
			for pn,po in self.Context.Plugins.items():
				if po.Category == c:
					self.Categories[c].append(po)
		self.ResetMainWidgets()

	def ResetMainWidgets(self):
		PluginsVPort = gtk.Viewport()
		LeftChild = gtk.VBox(False,10)
		LeftChild.set_border_width(15)
		FLab = MakeLabel()
		FLab.set_markup("<span color='%s' size='large' weight='800'>Filter</span>"%self.BrightColor)
		LeftChild.pack_start(FLab,False,False)
		FLen = gtk.Entry()
		LeftChild.pack_start(FLen,False,False)
		ILab = MakeLabel()
		ILab.set_markup("<span color='%s' size='large' weight='800'>Information</span>"%self.BrightColor)
		LeftChild.pack_start(ILab,False,False)
		PluginsVPort.modify_bg(gtk.STATE_NORMAL,gtk.gdk.color_parse('#ffffff'))
		RightChild = gtk.ScrolledWindow()
		RightChild.props.hscrollbar_policy = gtk.POLICY_AUTOMATIC
		RightChild.props.vscrollbar_policy = gtk.POLICY_AUTOMATIC
		RightChild.add(PluginsVPort)
		self.BuildTable(PluginsVPort)
		RightChild.connect('size-allocate',self.RebuildTable)
		self.SetMainWidgets(LeftChild,RightChild)

	def BuildTable(self,vp):
		PW = gtk.VBox()
		PW.set_border_width(10)
		vp.add(PW)
		self.TableCats={}
		self.TableAttached=False
		self.LastCols=-1
		for c in sorted(self.Categories,self.CatSortCompare):
			pl = self.Categories[c]
			CatBox = gtk.VBox()
			PW.pack_start(CatBox,False,False)
			CatHeader = gtk.HBox()
			CatLabel = MakeLabel('',-1)
			CatLabel.set_markup("<span color='#aaa' size='x-large' weight='800'>%s</span>"%(c or 'Uncategorized'))
			CatImg = self.MakeImage(category=c.lower().replace(" ", "_"))
			if CatImg:
				CatHeader.pack_start(CatImg,False,False)
			CatHeader.pack_start(CatLabel,False,False)
			CatBox.pack_start(CatHeader,False,False)
			CatTab = gtk.Table()
			CatTab.set_border_width(10)
			self.TableCats[c]=(CatTab,[],[])
			CatBox.pack_start(CatTab,False,False)
			for po in pl:
				CB = gtk.Button()
				CB.connect('clicked',self.SelectPlugin,po)
				CB.set_size_request(200,-1)
				CB.set_relief(gtk.RELIEF_NONE)
				CX = gtk.HBox(False,10)
				CX.set_border_width(10)
				CI = self.PluginImages[po.Name]
				CX.pack_start(CI,False,False)
				CL = MakeLabel(po.ShortDesc,120)
				CX.pack_start(CL,True,True)
				CB.add(CX)
				CH = gtk.HBox()
				if po.Name != 'core':
					CE = gtk.CheckButton()
					CE.set_active(po.Enabled)
					CE.connect("toggled",self.EnablePlugin,po)
					CH.pack_start(CE,False,False)
				CH.pack_start(CB,True,True)
				CH.set_size_request(223,-1)
				self.TableCats[c][1].append(CH)
				self.TableCats[c][2].append(po)

	def RebuildTable(self,wid,req):
		cols = (req.width-60)/223
		if cols == self.LastCols:
			return
		self.LastCols = cols
		if self.TableAttached:
			for CN,CW in self.TableCats.items():
				for CB in CW[1]:
					CW[0].remove(CB)
		for CN,CW in self.TableCats.items():
			col = 0
			row = 0
			for CB in CW[1]:
				CW[0].attach(CB,col,col+1,row,row+1,0)
				col = col + 1
				if col >= cols:
					col = 0
					row = row + 1
			CW[0].attach(gtk.Label(),cols+5,cols+6,0,1,gtk.EXPAND)
		self.TableAttached=True
		self.MainWin.show_all()

	def SetMainWidgets(self,lw,rw):
		p = self.LeftPane.get_child()
		if p:
			p.destroy()
		self.LeftPane.add(lw)
		p = self.RightPane.get_child()
		if (p):
			p.destroy()
		self.RightPane.add(rw)
		self.MainWin.show_all()

	def CatSortCompare(self,v1,v2):
		if v1 == v2:
			return cmp(v1,v2)
		if v1 == 'General':
			return cmp('',v2 or 'zzzzzzzz')
		if v2 == 'General':
			return cmp(v1 or 'zzzzzzz','')
		return cmp(v1 or 'zzzzzzzz',v2 or 'zzzzzzzz')

	def MakeImage(self,plugin=0,category=0,size=32):
		Img = gtk.Image()
		try:
			if plugin != 0:
				Pbf = gtk.gdk.pixbuf_new_from_file_at_size("%s/plugin-%s.svg"%(
					PixmapDir,plugin.Name),size,size)
				Img.set_from_pixbuf(Pbf)
			elif category != 0:
				Pbf = gtk.gdk.pixbuf_new_from_file_at_size("%s/category-%s.svg"%(
					PixmapDir,category),size,size)
				Img.set_from_pixbuf(Pbf)
		except:
			Img.set_from_stock(gtk.STOCK_MISSING_IMAGE,gtk.ICON_SIZE_BUTTON)
		return Img

	def SelectPlugin(self,obj,select):
		for nam,val in self.PluginImages.items():
			w = val.get_parent()
			if w:
				w.remove(val)
		pc = PluginClass(select,self)
		self.SetMainWidgets(pc.LeftWidget,pc.RightWidget)

	def EnablePlugin(self,widget,plugin):
		#attempt to resolve conflicts...
		conf = plugin.Enabled and plugin.DisableConflicts or plugin.EnableConflicts
		if HandlePluginConflicts(conf):
			plugin.Enabled = widget.get_active()
			for cat,container,plugins in self.TableCats.values():
				for i in range(len(plugins)):
					if plugins[i].Name != 'core':
						container[i].get_children()[0].set_active(plugins[i].Enabled)
		else:
			widget.set_active(plugin.Enabled)
		Write(plugin.Context)
		

	def BackToMain(self,obj):
		self.ResetMainWidgets()

MainWin = MainWinClass(ccs.Context()).MainWin
MainWin.show_all()
gtk.main()
